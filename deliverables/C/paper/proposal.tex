\chapter{Completed Work}\label{ch:style}

We have expanded upon the existing Cogent infrastructure keeping in mind
three major requirements: the ability for programmers to create recursive iterable data structures via
recursive types, the necessity for our programs to be easily proven \textit{total},
and the preservation of the benefits guaranteed by Cogent's uniqueness type system.

Our proposed design has been implemented in \textit{Minigent}, a stripped down version of Cogent that
features only the type checking component of Cogent. This allows us to
focus on the design of our recursive types without having to change
the compiler's C code generation, Isabelle/HOL embedding and
refinement proof linking the two.

We have incorporated our proposed design into the parsing, lexing, reorganising and 
typechecking compiler phases of Minigent. Moreover we provide 
a formalisation of termination checking for primitive recursive functions.
In addition to ensuring that the existing test suite in the Minigent 
typechecker still works, we have added additional tests 
to test the newly added recursive types.

\section{Grammar and Syntax}

\begin{figure}
    \centering
    \begin{align*}
        \text{types } \tau
            ::= \dots\; &|\; \mu\; \{ \overline{f_i^u\; \tau_i} \} \\
                        &|\; t_r \\
        \text{recursive parameters }\mu ::&= \textbf{mu}\; t\; |\; \varepsilon
    \end{align*}
    \caption{Extending our record syntax with recursive parameters}
    \vspace{2em}
    \label{fig:mu}
\end{figure}

\begin{figure}
    \centering
    \begin{tabular}{l}
        \textbf{type} List = \textbf{mu} $t$ \{ \\
            \phantom{x}\hspace{2em}\textit{l}: $\langle\;$ \\
            \phantom{x}\hspace{4em} $\text{Cons } (t,\textsc{U32})\;$ \\
            \phantom{x}\hspace{3.7em}$|\; \text{Nil } ()\;$ \\
            \phantom{x}\hspace{2em}$\rangle$ \\
        \} 
    \end{tabular}
    \vspace{2em}
    \caption{Constructing the List datatype using recursive parameters}
    \label{fig:muexample}
\end{figure}

We have extended the existing record grammar with an optional recursive parameter \textbf{mu} presented in
\autoref{fig:mu} to add recursive type parameters to Cogent's boxed records, this enables the use
of recursive parameter variables in the language.

Boxed records now feature an optional recursive type variable bound by the \textbf{mu} keyword, which may
optionally feature in a record type in which they are bound. This also ensures our new record syntax is
backwards compatible with the previous record syntax, enabling existing Cogent programs to remain unchanged.

\autoref{fig:muexample} demostrates the use of our new grammar to construct an integer list datatype,
with the use of a variant type in a recursive record field \textit{l} that is either Nil,
the end of the list, or Cons, the current integer and the rest of the list. Further
examples are discussed in \autoref{ch:examplesandtesting} at the end of the chapter.

\section{Strictly Positive Types}

\begin{figure}
    \centering
    \begin{gather*}
    \begin{split}
        \textbf{RP}(\textbf{mu } t) &= \{t\} \\
        \textbf{RP}(\varepsilon) &= \{\}
    \end{split} \\[10pt]
    \infer[\textsc{sp-rec}]{
        \mathcal{S}; \mathcal{B} \vdash \mu\; \{\overline { f_i : \tau_i } \} \textbf{ SP}
    }{
        \mathcal{S}\setminus \textbf{RP}(\mu), \mathcal{B} \cup \textbf{RP}(\mu) \vdash \tau_i \textbf{ SP}
    }
    \hspace{3em}
    \infer[\textsc{sp-var}]{
        \mathcal{S}; \mathcal{B} \vdash \langle\overline{\kappa_i : \tau_i}\rangle \textbf{ SP}
    }{
        \mathcal{S}; \mathcal{B} \vdash \tau_i \textbf{ SP}
    } \\[10pt]
    \hspace{3em}
    \infer[\textsc{sp-func}]{
        \mathcal{S}; \mathcal{B} \vdash \tau_1 \rightarrow \tau_2 \textbf{ SP}
    }{
        \mathcal{S} \cup \mathcal{B}; \mathcal{B} \vdash \tau_1 \textbf{ SP}
        &
        \mathcal{S}; \mathcal{B} \vdash \tau_2 \textbf{ SP}
    } \\[10pt]
    \infer[\textsc{sp-rvar}]{
        \mathcal{S}; \mathcal{B} \vdash t_r \textbf{ SP}
    }{
        t_r \notin \mathcal{S}
    }
    \hspace{2em}
    \infer[\textsc{sp-prim}]{
        \mathcal{S}; \mathcal{B} \vdash \mathcal{T} \textbf{ SP}
    }{}
    \hspace{2em}
    \infer[\textsc{sp-tvar}]{
        \mathcal{S}; \mathcal{B} \vdash a \textbf{ SP}
    }{}
    \end{gather*}
    \caption{The rules for checking that Cogent types are strictly positive}
    \label{fig:strictlypositivecheck}
\end{figure}

Checking that all types only occur \emph{strictly positive} has been implemented in the reorganisation phase of the compiler
instead of during type checking. This allows for a simple one-pass algorithm that can 
analyse all the types in the program at once, and a simpler contraint generation and solving phases.

\autoref{fig:strictlypositivecheck} describes the strictly positive check over Cogent's types.
This algorithm keeps track of a set of in scope bound recursive parameters $\mathcal{B}$ and a set of recursive
parameters currently appear in a non-strictly positive position $\mathcal{S}$.

Rule \textsc{sp-rec} describes checking a record bound with a recursive parameter $t$, where parameter 
is added to the bound set $\mathcal{B}$, and removed from the non-strictly positive set $\mathcal{S}$
(as these variables can shadow previous variables), where $\textbf{RP}(\mu)$ returns the recursive
parameter variable in $\mu$ if the $\mu$ has one.

Rule \textsc{sp-func} describes checking a function type, where checking the argument position $\tau_1$ adds
all currently bound ($\mathcal{B}$) parameters to the non-strictly positive set ($\mathcal{S}$), and then
checking the result position $\tau_2$.

Rule \textsc{sp-rvar} describes checking a recursive parameter variable $t_r$, requiring that it is not currently
in a non-strictly positive position (i.e. not in the $\mathcal{S}$ set). 

\textsc{sp-var} merely descends on the types nested within a variant,
\textsc{sp-prim} allows for primitive types ($\mathcal{T}$) and
\textsc{sp-tvar} allows for type variables ($a$).

Once strictly positive typing is checked, the reorganiser will embed all used recursive parameter variables
with a reference to the recursive boxed record that they were bound to, which is used during the constraint
solving phase.

\section{Typing and Constraint Generation Rules}

% Unboxed Not Recursive check
\begin{figure}
    \centering
    $$
        \infer{
            \mu \text{ \textcircled{u} } \textbf{UnboxedNotRecursive}
        }{
            \mu = \varepsilon
        }
    $$
    $$
        \infer{
            (\textbf{mu } t) \text{ s } \textbf{UnboxedNotRecursive}
        }{
            s \neq \text{\textcircled{u}}
        }
    $$
    \caption{A constraint checking that recursive parameters are used only with boxed records}
    \label{fig:unboxednotrecursive}
\end{figure}

% PUT typing rule
\begin{figure}
    \centering
    \begin{align*}
        \infer[\textsc{\footnotesize{Put}}]{
            A;\Gamma \vdash \textsf{put } e_1.f_k  = e_2 : \; \mu \; \{ \overline{f_i^u : \tau_i}, f_k^\circ : \tau_k \} s
        }{
            \begin{array}{c}
                A;\Gamma \vdash e2 : \tau_k
                \hspace{2em}
                A \vdash \Gamma \rightsquigarrow \Gamma_1 \boxplus \Gamma_2
                \hspace{2em}
                s \neq \text{\textcircled{r}}
                \vspace{0.5em} \\
                A;\Gamma_1 \vdash e_1\; : \mu\; \{ \overline{f_i^u : \tau_i}, f_k^\bullet : \tau_k \}\; s
                \vspace{0.5em} \\
                A \vdash \mu \textit{ s } \textbf{UnboxedNotRecursive}
            \end{array}
        }
    \end{align*}
    
    \caption{The updated typing rule for \textsc{put}}
    \label{fig:puttypingrule}
\end{figure}

% TAKE typing rule
\begin{figure}
    \centering
    \begin{align*}
        \infer[\textsc{\footnotesize{Take}}]{
            A;\Gamma \vdash \textsf{take } r \{ f_k = y \} = e1 \textsf{ in } e_2 : \tau
        }{
            \begin{array}{c}
                A \vdash \Gamma \rightsquigarrow \Gamma_1 \boxplus \Gamma_2
                \hspace{3em}
                A;\Gamma_1 \vdash e_1\; : \mu\; \{ \overline{f_i^u : \tau_i}, f_k^\circ : \tau_k \}\; s
                \vspace{0.5em} \\
                A \vdash \mu \textit{ s } \textbf{UnboxedNotRecursive}
                \hspace{3em}
                s \neq \text{\textcircled{r}}
                \vspace{0.5em} \\
                A; r : \mu\; \{ \overline{f_i^u : \tau_i}, f_k^\bullet : \tau_k \}\; s
                ,\; y : \tau_k,\; \Gamma_2 \vdash e_2 : \tau
            \end{array}
        }
    \end{align*}
    
    \caption{The updated typing rule for \textsc{take}}
    \label{fig:taketypingrule}
\end{figure}

% MEMBER typing rule
\begin{figure}
    \centering
    \[
        \infer[\textsc{\footnotesize{Member}}]{
            A;\Gamma \vdash e.f_k : \tau
        }{
            A;\Gamma \vdash e : \mu\; \{ \overline{f_i^\bullet : \tau_i}, f_k^\circ : \tau_k \}\; s
            &\hspace{1em}
            A \vdash \mu \textit{ s } \textbf{UnboxedNotRecursive}
        }
    \]
    
    \caption{The updated typing rule for \textsc{Member}}
    \label{fig:membertypingrule}
\end{figure}

% MEMBER constraint gen rule
\begin{figure}
    \centering
    \[
        \infer[\textsc{\footnotesize{CG-Member}}]{
            G \vdash e.f : \tau \rightsquigarrow G'\; |\; C_1 \land C_2 \land C_3
        }{
            \begin{array}{c}
                \alpha, \beta, \gamma\; \text{fresh}
                \hspace{2em}
                G \vdash e : \gamma\; \{ f^\circ : \tau | \alpha \}\; \beta \rightsquigarrow G'\; |\; C_1 \\[5pt]
                C_2 = \gamma\; \{ f^\bullet : \tau | \alpha \}\; \beta\; \textbf{Drop}
                \hspace{2em}
                C_3 = \gamma\; \beta\; \textbf{UnboxedNotRecursive}
            \end{array}
        }
    \]
    
    \caption{The updated constraint generation rule for \textsc{Member}}
    \label{fig:memberconstraintgen}
\end{figure}

% TAKE constraint gen rule
\begin{figure}
    \centering
    \[
        \infer[\textsc{\footnotesize{CG-Take}}]{
            G_1 \vdash \textsf{take } x\; \{ f = y \} = e_1 \textsf{ in } e_2
                : \tau \rightsquigarrow G_3 | \bigwedge_{k \in 1..6} C_k
        }{
            \begin{array}{c}
                \alpha, \beta, \gamma, \delta \text{ fresh}
                \hspace{1em}
                G_1 \vdash e : \delta\; \{ f^\circ : \beta\; |\; \alpha \}\;
                    \gamma \rightsquigarrow G_2\; |\; C_1 \\[7pt]
                x :_{\langle 0 \rangle} \delta \{ f^\bullet : \beta | \alpha \} \gamma,\;
                    y :_{\langle 0 \rangle} \beta,\;
                    G_2 \vdash e_2 : \tau 
                     \rightsquigarrow     
                    x :_{\langle n \rangle} \delta \{ f^\bullet : \beta | \alpha \} \gamma,\;
                    y :_{\langle m \rangle} \beta,\;
                    G_3\; |\; C_2 \\[7pt]
                C_3 = \text{if } n = 0 \text{ then } 
                    \delta\; \{ f^\bullet : \beta\; |\; \alpha\; \}\; \gamma \textbf{ Drop}
                    \text{ else } \top \\[5pt]
                C_4 = \text{if } m = 0 \text{ then } 
                    \beta \textbf{ Drop}
                    \text{ else } \top \\[5pt]
                C_5 = \gamma \neq \text{\textcircled{r}}
                \hspace{2em}
                C_6 = \delta\; \gamma \textbf{ UnboxedNotRecursive}
            \end{array}
        }
    \]
    
    \caption{The updated constraint generation rule for \textsc{Take}}
    \label{fig:takeconstraintgen}
\end{figure}

% PUT constraint gen rule
\begin{figure}
    \centering
    \[
        \infer[\textsc{\footnotesize{CG-Put}}]{
            G_1 \vdash \textsf{put } e_1.f = e_2 : \tau \rightsquigarrow G_3\; 
                |\; \bigwedge_{k \in 1..5} C_k
        }{
            \begin{array}{c}
                \alpha, \beta, \gamma, \delta \text{ fresh}
                \hspace{2em}
                G_1 \vdash e_1 : \delta\; \{ f^\bullet: \tau | \alpha \}\; 
                    \gamma \rightsquigarrow G_2\; |\; C_1 \\[5pt]
                G_2 \vdash e_2 : \beta \rightsquigarrow G_3\; |\; C_2
                \hspace{2em}
                C_3 =  \delta\; \{ f^\circ : \tau | \alpha \}\; 
                    \gamma \subtype \tau
                \hspace{2em}
                C_4 = \gamma \neq \text{\textcircled{r}} \\[5pt]
                C_5 = \delta\; \gamma \textbf{ UnboxedNotRecursive}
            \end{array}
        }
    \]
    
    \caption{The updated constraint generation rule for \textsc{Put}}
    \label{fig:putconstraintgen}
\end{figure}

Our typing rules and Constraint generation rules have only been changed only to check one extra
constraint on records - that recursive parameters are only used on boxed records. The check for this
new constraint is outlined in \autoref{fig:unboxednotrecursive}

We modify the original \textsc{Take}, \textsc{Put} and \textsc{Member} typing rules defined by
\citet{LiamThesis} to include this constraint as presented in \autoref{fig:puttypingrule},
\autoref{fig:taketypingrule} and \autoref{fig:membertypingrule}.

Next, we modify the \textsc{CG-Member}, \textsc{CG-Take} and \textsc{CG-Put} to account
for constraint generation. Our new constraints will be generated
as defined by \autoref{fig:takeconstraintgen}, \autoref{fig:putconstraintgen} and 
\autoref{fig:memberconstraintgen}, to also include this new constraint.

Each of these rules additionally now includes an extra fresh unification variable, which is
used to infer the recursive parameter of a given record. These variables are substituted
for real recursive parameters during the constraint solver's \textit{unification} phase.

\section{Constraint Solver Rules}

\begin{figure}
    \centering
    \begin{align}
       t_r  &\subtype \tau  & \simp  && \textbf{unroll } t_r  &\subtype  \tau \label{eq:firsteq} \\
       \tau &\subtype t_r   & \simp  && \tau                  &\subtype  \textbf{unroll } t_r \\
       t_r  &\typeeq  \tau  & \simp  && \textbf{unroll } t_r  &\typeeq   \tau \\
       \tau &\typeeq  t_r   & \simp  && \tau                  &\typeeq   \textbf{unroll } t_r \label{eq:lasteq} \\
       t_r  &\typeeq  k_r   & \simp  && \textbf{unroll } t_r  &=         \textbf{unroll } k_r \label{eq:firstrecs} \\
       t_r  &\subtype k_r   & \simp  && \textbf{unroll } t_r  &=         \textbf{unroll } k_r \label{eq:lastrecs} \\
       (\textbf{mu } t)\; &s\; \textbf{UnboxedNotRecursive}   
            & \simp &&  s = \text{\textcircled{r}} &\lor s = \text{\textcircled{w}} \label{eq:firstunbox} \\
       \varepsilon\; &\text{\textcircled{u}}\; \textbf{UnboxedNotRecursive} 
            & \simp &&  &\varepsilon \label{eq:lastunbox}
    \end{align}
    \caption{The new simplification rules}
    \label{fig:simprules}
\end{figure}

\begin{figure}
    \centering
    \[
        \textbf{unroll } t_r = \textbf{mu } t\; \{ \overline{f_i^u : \tau_i} \} 
    \]
    \caption{the \textbf{unroll} operator, which expands a recursive parameter
             to its recursive reference}
    \label{fig:unrolldef}
\end{figure}

The constraint solver now contains additional rules in order to reason about recursive
records, which have changed the \textit{simplification} and \textit{unification}
constraint solving phases.

\subsection{Simplification Phase}

In the simplification phase, the rules described in \autoref{fig:simprules} allow
the solver to reason about recursive types that feature in the comparison constraints
subtyping ($\subtype$) and type equality ($\typeeq$). \autoref{eq:firsteq}
through to \autoref{eq:lasteq} state that
when a recursive type $t_r$ is directly compared against a type $\tau$, the solver
can \textbf{unroll} $t_r$, as defined in \autoref{fig:unrolldef}.
Additionally, \autoref{eq:firstrecs} and \autoref{eq:lastrecs} 
cover the case where we compare two recursive parameters
$t_r$ and $k_r$, where \textbf{unroll}ing both parameters results
in the same type via meta equality.

\autoref{eq:firstunbox} and \autoref{eq:lastrecs} allow for the elmination of \textbf{UnboxedNotRecursive} constraints
given that either the recursive parameter is nothing ($\varepsilon$) and the sigil is
unboxed (\textcircled{u}), or that the recursive paremeter is some \textbf{mu} $t$ and
the accompanying sigil $s$ is readonly (\textcircled{r}) or writable (\textcircled{w}).

\subsection{Unification Phase}

The unification phase now unifies unknown recursive parameters that are embedded
on records. Given constraints of the form 
$\alpha\; \{ \dots \} \subtype \mu\; \{ \dots \}$ or of the form
$\alpha\; \{ \dots \} \typeeq \mu\; \{ \dots \}$, where $\alpha$ is a unification
variable and $\mu$ is a concrete recursive parameter, we can simply replace all
$\alpha$ with $\mu$ without an occurs check, and add the substitution 
$\alpha := \mu$ to our set of assignments that the solver will output. 
This is true symmetrically, when the left and right hand sides of the above
constraints are swapped.

The unification phase also unifies recursive parameters in an \textbf{UnboxedNotRecursive}
constraint to nothing ($\varepsilon$) if the sigil in that constraint has been unified to
an unboxed sigil (\textcircled{u}). If this unification variable was meant to be a recursive
parameter $t_r$, then the constraint solving will fail elsewhere due to this substitution,
preserving the correctness of the solver.


\section{Example Usage and Testing}
\label{ch:examplesandtesting}

\begin{figure}
    \centering
    \[
        \begin{array}{l}
            [a].\; \textbf{mu}\ t\; \{ \\
            \hspace{2em} l: < \\
            \hspace{4em}    \text{Nil Unit} \\
            \hspace{3.3em}  |\ \text{Cons}\; \{\; \text{data}: a,\; \text{rest}: t\; \}\# \\ 
            \hspace{2em} > \\
            \}
        \end{array}    
    \]
    \caption{A polymorphic list datatype in Minigent}
    \label{fig:minigentlist}
\end{figure}

We present a list datatype in \autoref{fig:minigentlist}, which was implemented in Minigent during the course
of testing our implmenetation. As Minigent's syntax is not as rich as the full compiler's,
our definition differs from that of \autoref{fig:muexample}, as we are unable to create
type aliases (i.e. $\textbf{type}\; \text{List} = \dots$) and unable to use tuples,
which are replaced with an unboxed record instead.

\begin{figure}
    \centering
    \[
        \begin{array}{l}
            \text{sumList} : \textsf{mu}\; t\; \{\; \text{l}: < \text{Nil Unit}\; |\; \text{Cons}\; \{\; \text{data}: \textsf{U32},\; \text{rest}: t!\; \}\# >\}!
                \rightarrow \textsf{U32}; \\
            \text{sumList}\; r = \\
            \hspace{1em}    \textsf{take}\; r'\; \{ l = l \} = r\; \textsf{in}  \\
            \hspace{2em}    \textsf{case}\; l\; \textsf{of} \\
            \hspace{3em}        \text{Nil}\; u\; \rightarrow\; 0 \\
            \hspace{3em}    |\; v2 \rightarrow \\
            \hspace{4em}    \textsf{case}\; v2\; \textsf{of} \\
            \hspace{5em}    \text{Cons}\; s\; \rightarrow  \\
            \hspace{6em}    \textsf{take}\; s'\; \{ rest = x \} = s\; \textsf{in} \hspace{2em} \\
            \hspace{7em}        s.data\; +\; \text{sumList}\; x \\
            \hspace{6em}    \textsf{end} \\
            \hspace{4em}    \textsf{end} \\
            \hspace{2em}    \textsf{end} \\
            \hspace{1em}    \textsf{end}
        \end{array}
    \]
    
    \caption{A function that sums a list of 32 bit integers}
    \label{fig:listsum}
\end{figure}

A simple use of this list can be seen in \autoref{fig:listsum}, which sums a list of
32 bit integers (\textsf{U32}). Our recursive call is on a variable $x$, which has
the linear type $t!$, which the compiler will unroll and then propogate the bang ($!$)
through the unrolled type via the normaliser.

\begin{figure}
    \centering
    \[
    \begin{array}{l}
\text{alloc} : [x].\; \text{Unit} \rightarrow \textsf{mu}\; t\; \{\; \text{l}: < \text{Nil Unit}\; |\; \text{Cons}\; \{\; \text{data}: x,\; \text{rest}: t\; \}\# > \textsf{take}\; \}; \\[10pt]

\text{map} : [a,b].\; \\
\hspace{5em}
    \{\; \text{list}: \textsf{mu}\; t\; \{\; l: < \text{Nil Unit}\; |\; \text{Cons}\; \{\; \text{data}: a,\; \text{rest}: t\; \}\# > \}!,\; \text{f}: (a -> b)\; \}\# \\
\hspace{5em}
    \rightarrow \textsf{mu}\; t\; \{\; l: < \text{Nil Unit}\; |\; \text{Cons}\; \{\; \text{data}: a,\; \text{rest}: t\; \}\# > \}; \\
\text{map}\; l =  \\
\hspace{1em}
\textsf{take}\; l2\; \{\; \text{list} = node\; \} = l\; \textsf{in} \\
\hspace{2em} 
\textsf{take}\; l3\; \{\; \text{f} = fun\; \} = l2\; \textsf{in} \\
\hspace{3em} 
\textsf{take}\; node2\; \{\; \text{l} = head\; \}\; = node\; \textsf{in} \\
\hspace{4em} 
\textsf{case}\; head\; \textsf{of} \\
\hspace{5em} 
\text{Nil}\; u \rightarrow  \\
\hspace{6em} 
\textsf{let}\; newNode = \text{alloc Unit}\; \textsf{in}  \\
\hspace{7em}
\textsf{put}\; newNode.l := \text{Nil Unit}\; \textsf{end} \\
\hspace{6em} 
\textsf{end} \\
\hspace{5em} 
|\; v2 \rightarrow  \\
\hspace{6em} 
\textsf{case}\; v2\; \textsf{of} \\
\hspace{7em} 
\text{Cons}\; remaining \rightarrow \\
\hspace{8em} 
\textsf{take}\; remaining2\; \{\; \text{data} = x\; \} = remaining\; \textsf{in}  \\
\hspace{9em} 
\textsf{let}\; newNode = \text{alloc Unit}\; \textsf{in} \\
\hspace{10em} 
\textsf{put}\; newNode.l :=  \\
\hspace{14em} 
\text{Cons}\; \{ \\
\hspace{15em}
\text{data} = \text{fun} x, \\
\hspace{15em} 
\text{rest} = \text{map}\; \{\; \text{list} = remaining2.rest,\; \text{f} = fun \} \\
\hspace{14em} 
\}\; \textsf{end} \\
\hspace{10em} 
\textsf{end} \\
\hspace{9em} 
\textsf{end} \\
\hspace{7em} 
\textsf{end} \\
\hspace{4em} 
\textsf{end} \\
\hspace{3em} 
\textsf{end} \\
\hspace{2em} 
\textsf{end} \\
\hspace{1em} 
\textsf{end};
        
    \end{array}    
    \]
    
    \caption{Map for lists implemented in Minigent}
    \label{fig:listmap}
\end{figure}

We can write common functions that operate on lists, such as \textsf{map},
as in \autoref{fig:listmap}. While our implementation is very verbose in Minigent,
the full compiler's syntactic sugar would allow for a much more simplified
implementation with tuples and more compact \textsf{case} statements.

It can be seen in our recursive call to map, we pass \textit{remaining2.rest} and
\textit{fun} as our arguments, being the tail and mapping function for the list
respectively. As \textit{remaining2.rest} has the type of the recursive paramater
for the list \textit{t}, our solver unrolls this variable as described in order
to ensure the recursive call has been given expressions of the correct type.

\begin{figure}
    \centering

    \[
        \begin{array}{l}
            [a].\; \textsf{mu}\; t\; \{\; \\
            \hspace{2em} \text{f}: < \\
            \hspace{4em} \text{Leaf Unit}\; \\
            \hspace{3.3em} |\; \text{Node}\; \{\; \text{left}: t,\; \text{right}: t,\; \text{data}: a \}\# \\
            \hspace{2em} >  \\
            \}
        \end{array}
    \]
    
    \caption{A polymorphic tree datatype in Minigent}
    \label{fig:minigenttree}
\end{figure}

Furthermore, we can create a tree datatype in Minigent as shown in \autoref{fig:minigenttree}.
The tree type resembles our list datatype but with two fields that have the type of our
\textsf{mu} quantified recursive parameter $t$, the left and right branches of the tree.

\section{Termination}

A primitive recursion detection scheme has been designed to check the termination
of functions that structurally recurse on our new recursive types. This introduces
a new phase into the compiler; the \textit{termination checker}.

\subsection{Design}

Our new termination checker works by generating assertions about the structural
size of variables passed to the function, similar to the approach
taken by \citet{Foetus}. When recursive calls are made, the termination checker
uses these assertions to check that the structural size of the argument to the
recursive call is strictly smaller than that of the function argument. Hence, the argument
given to a recursive call will only ever grow smaller, and therefore the function will
eventually reach the \emph{bottom} of the structure and terminate.
As all recursive types constructed must be finite due to our use of strictly positive
types and Cogent's linear type system (i.e. no infinitely looping structures),
all primitive recursive calls will terminate.

Our size assertions take the form of two relations between variables, 
size inequality ($\tlt$) and size equality ($\teq$).
$x \tlt y$ is the assertion that a variable $x$ is strictly
structurally smaller than a varialbe $y$ and, $x \teq y$ is the assertion that a
varialbe $x$ is structurally equal in size to a variable $y$.

The checker starts with a set of known termination assertions $G$, and then adds
extra assertions by analysing the expression body of a function to produce
a stronger set of assertions $G'$, as well as a set of expressions that are arguments
to recursive function calls $C$. \autoref{fig:terminationcondition} describes the
condition for soundness of our termination checker. For our check to be \emph{complete},
our checker would need to show all nonterminating functions are invalid.
As a consequence of the halting problem however, this completeness is impossible
so our checker only attempts to check for primitive recursion.

\begin{figure}
    \centering
    \[
        \begin{array}{ll}
            f\; x = e              
                & \text{Given a function definition} \\[10pt]
            \implies \alpha \leftarrow x;\; \varnothing 
                \vdash e \rightsquigarrow G'\; |\; E'\; |\; C
                \hspace{2em}
                & \text{And a set of assertions and goals} \\
                & \text{generated by the termination checker} \\
                & \text{from an initial environment and} \\
                & \text{empty set of assertions} \\[10pt]
            \implies G' \vdash \forall \beta \in C.\; \beta \tlt \alpha
                & \text{The function terminates if} \\
                & \text{every goal expression produced} \\
                & \text{is smaller than the function argument} \\
                & \text{under the produced assertions}
        \end{array}
    \]
    
    \caption{The termination checker soundness condition}
    \label{fig:terminationcondition}
\end{figure}

We generate such assertions by looking at Cogent's expression langauge 
where any form of structural size is added or taken away, namely
\textsf{take}, \textsf{put} and \textsf{case} expressions.
\autoref{fig:terminationassertiongen} describes this assertion generation.

However, if a user were to shadow a variable in a let expression they may
create a false assertion. Consider the expression 
$\textsf{let } x = C\; x \textsf{ in } \dots$, which would produce the
assertion $x \teq C\; x$, which by our structural size rules can be rewritten as
$x \tlt x$, which is clearly false.

We prevent this from occuring by using a fresh variable name for every
introduced varaible in scope, and use these fresh names in our assertions.
We also store a mapping of program variables to fresh variables names in a
context $E$, which we update as we encounter new variable definitions in the
function expression.

With our current method of size relations, we are unable to reason about variables
compared against any general expression. For example, suppose the assertion $x \tlt C\; y$.
This assertion is useless to us as we have no way of reasoning about $x$ and $y$ directly,
and we are unable to remove the constructor $C$ as we have no information about the
gap in size between $x$ and $y$. We could have $x \tlt y$ if $x$ is more than one layer
of structure smaller than y, or $x \teq y$ if x is only one layer of structure smaller.

We seek a way to eliminate such assertions from being generated. To do this,
we define a function \textsf{get} in \autoref{fig:getdef} that maps an expression to
a fresh variable name if the expression is a program variable and otherwise nothing 
($\varepsilon$).
Whenever we generate an assertion against an expression $e$, we use the result
of $\textsf{get}(E,e)$ in the assertion, which will also insert the correct fresh
variable name in the assertion.


\begin{figure}
    \centering
    \[
        \textsf{get}(E, e) = \textsf{if } e = t \textsf{ then } E[t] \textsf{ else } \varepsilon
    \]
    
    \caption{The definition of \textsf{get}}
    \label{fig:getdef}
\end{figure}

After generating all of our assertions, we filter out any assertions that include a nothing ($\varepsilon$),
as we cannot reason about them in any way, or fail if any goal contains a nothing. While this solution may
not be as complete as it possibly could be, we may still use our remaining assertions
to prove termination in some cases.

\begin{figure}
    \centering
    \[
        \fbox{$E; G \vdash e : \tau \rightsquigarrow G'\; |\; E'\; |\; C$}
    \]
    \[
        \infer[\textsc{\footnotesize T-Take}]{
            E_1; G_1
                \vdash \textsf{take } r'\; \{ f = x \} = e_1 \textsf{ in } e_2
                \rightsquigarrow G_3\; |\; E_3\; |\; C_1 \cup C_2
        }{
            \begin{array}{c}
            \alpha, \beta\; \textsf{fresh}
            \hspace{1em}
            E_1; \alpha \tlt \textsf{get}(E_1,e_1),\; \textsf{get}(E_1,e_1) \teq \beta,\; G_1 \vdash e_1
                \rightsquigarrow G_2\; |\; E_2\; |\; C_1 \\[5pt]
            E_1, \alpha \leftarrow x, \beta \leftarrow r'; G_2 \vdash e_2 \rightsquigarrow G_3\; |\; E_3\; |\; C_2
            \end{array}
        }
    \]
    \vspace{0.5pt}
    \[
        \infer[\textsc{\footnotesize T-Put}]{
            E_1; G_1 \vdash \textsf{put } e_1.f := e_2
                \rightsquigarrow G_3\; |\; E_1\; |\; C_1 \cup C_2
        }{
            \begin{array}{c}
                \alpha, \beta\; \textsf{fresh} \\[5pt]
                E_1; \alpha \tlt \beta,\; \beta \teq \textsf{get}(E_1,e_1),\; \alpha \teq \textsf{get}(E_1,e_2),\; 
                    G_1 \vdash e_1 \rightsquigarrow G_2\; |\; E_2\; |\; C_1 \\[5pt]
                E_1; G_2 \vdash e_2 \rightsquigarrow G_3\; |\; E_3\; |\; C_2
            \end{array}
        }
    \]
    \vspace{0.5pt}
    \[
        \infer[\textsc{\footnotesize T-Case}]{
            E_1; G_1 \vdash \textsf{case } e_1 \textsf{ of } \kappa\; x.\; e_2\; 
                \textsf{else}\; y.\; e_3
                \rightsquigarrow G_4\; |\; E_1\; |\; C_1 \cup C_2 \cup C_3
        }{
            \begin{array}{c}
                \alpha, \beta, \gamma\; \textsf{fresh}
                \hspace{1em}
                E_1;\; G_1,\; \beta \teq \textsf{get}(E_1, e_1)  \vdash e_1 
                    \rightsquigarrow G_2\; |\; E_2\; |\; C_1 \\[5pt]
                E_1, x \leftarrow \alpha;\; G_2, \alpha \tlt \beta 
                    \vdash e_2 \rightsquigarrow G_3\; |\; E_3\; |\; C_2 \\[5pt]
                E_1, y \leftarrow \gamma;\; G_3, \gamma \teq \beta 
                    \vdash e_3 \rightsquigarrow G_4\; |\; E_4\; |\; C_3
            \end{array}
        }
    \]
    \vspace{0.5pt}
    \[
        \infer[\textsc{\footnotesize T-CaseIrr}]{
            E_1; G_1 \vdash \textsf{case } e_1 \textsf{ of } \kappa\; x.\; e_2\; 
                \rightsquigarrow G_3\; |\; E_1\; |\; C_1 \cup C_2
        }{
            \begin{array}{c}
                \alpha, \beta\; \textsf{fresh}
                \hspace{1em}
                E_1;\; G_1,\; \beta \teq \textsf{get}(E_1, e_1)  \vdash e_1 
                    \rightsquigarrow G_2\; |\; E_2\; |\; C_1 \\[5pt]
                E_1, x \leftarrow \alpha;\; G_2, \alpha \tlt \beta 
                    \vdash e_2 \rightsquigarrow G_3\; |\; E_3\; |\; C_2
                \hspace{2em}
            \end{array}
        }
    \]
    \caption{Termination assertion generation rules}
    \label{fig:terminationassertiongen}
\end{figure}

\begin{figure}[]
    \centering
    \[
        \infer[\textsc{\footnotesize T-Member}]{
            E_1; G_1 \vdash e.f
                \rightsquigarrow G_2\; |\; E_1\; |\; C
        }{
            E_1; G_1 \vdash e_1 \rightsquigarrow G_2\; |\; E_2\; |\; C
        }
    \]
    \vspace{0.5pt}
    \[
        \infer[\textsc{\footnotesize T-Con}]{
            E_1; G_1 \vdash \kappa\; e
                \rightsquigarrow G_2\; |\; E_2\; |\; C
        }{
            E_1; G_1 \vdash e_1 \rightsquigarrow G_2\; |\; E_1\; |\; C
        }
        \hspace{1em}
        \infer[\textsc{\footnotesize T-TApp}]{
            E; G \vdash f\textbf{[}\harpoon{\tau_i}\textbf{]}
                \rightsquigarrow G\; |\; E\; |\; \varnothing
        }{
        }
    \]
    \vspace{0.5pt}
    \[
        \infer[\textsc{\footnotesize T-FApp}]{
            E_1; G_1 \vdash e_1\; e_2
                \rightsquigarrow G_3\; |\; E_1\; |\; C_1 \cup C_2 
                \cup \{\textsf{get}(E_1,e_2)\}
        }{
            E_1; G_1 \vdash e_1 \rightsquigarrow G_2\; |\; E_2\; |\; C_1
            \hspace{1em}
            E_2; G_2 \vdash e_2 \rightsquigarrow G_3\; |\; E_3\; |\; C_2
        }
    \]
    \vspace{0.5pt}
    \[
        \infer[\textsc{\footnotesize T-TVar}]{
            E; G \vdash x
                \rightsquigarrow G\; |\; E\; |\; \varnothing
        }{}
        \hspace{1em}
        \infer[\textsc{\footnotesize T-Lit}]{
            E; G \vdash \ell
                \rightsquigarrow G\; |\; E\; |\; \varnothing
        }{}
    \]
    \vspace{0.5pt}
    \[
        \infer[\textsc{\footnotesize T-PrimOp}]{
            E_1; G_1 \vdash e_1 \text{ \textasteriskcentered }\; e_2
                \rightsquigarrow G_3\; |\; E_1\; |\; C_1 \cup C_2
        }{
            E_1; G_1 \vdash e_1 \rightsquigarrow G_2\; |\; E_2\; |\; C_1
            \hspace{1em}
            E_2; G_2 \vdash e_2 \rightsquigarrow G_3\; |\; E_3\; |\; C_2
        }
    \]
    \vspace{0.5pt}
    \[
        \infer[\textsc{\footnotesize T-Let}]{
            E_1; G_1 \vdash \textsf{let } x = e_1 \textsf{ in } e_2
                \rightsquigarrow G_3\; |\; E_3\; |\; C_1 \cup C_2
        }{
            \begin{array}{c}
                \alpha \; \textsf{fresh}
                \hspace{1em}
                E_1; G_1 \vdash e_1 \rightsquigarrow G_2\; |\; E_2\; |\; C_1 \\[5pt]
                E_1, \alpha \leftarrow x; \alpha \teq \textsf{get}(E_2, e_1),\; G_2 \vdash e_2 
                    \rightsquigarrow G_3\; |\; E_3\; |\; C_2
            \end{array}
        }
    \]
    \vspace{0.5pt}
    \[
        \infer[\textsc{\footnotesize T-If}]{
            E_1; G_1 \vdash \textsf{if } e_1 \textsf{ then } e_2 \textsf{ else } e_3
                \rightsquigarrow G_4\; |\; E_1\; |\; C_1 \cup C_2 \cup C_3
        }{
            \begin{array}{c}
                E_1; G_1 \vdash e_1 \rightsquigarrow G_2\; |\; E_2\; |\; C_1 \\[5pt]
                E_1; G_2 \vdash e_2 \rightsquigarrow G_3\; |\; E_3\; |\; C_2
                \hspace{1em}
                E_1; G_3 \vdash e_3 \rightsquigarrow G_4\; |\; E_4\; |\; C_3
            \end{array}
        }
    \]
    \vspace{0.5pt}
    \[
        \infer[\textsc{\footnotesize T-Tysig}]{
            E_1; G_1 \vdash e :: \tau
                \rightsquigarrow G_2\; |\; E_1\; |\; C
        }{
            E_1; G_1 \vdash e \rightsquigarrow G_2\; |\; E_2\; |\; C
        }
    \]
    \vspace{0.5pt}
    \[
        \infer[\textsc{\footnotesize T-Struct}]{
            E_1; G_1 \vdash \{\overline{f_i = e_i}\}
                \rightsquigarrow G_{n+1}\; |\; E_1\; |\; \bigcup_{i = 1}^n C_i
        }{
            i \in \{1, \dots, n\}\quad  E_i; G_i \vdash e_i 
                \rightsquigarrow G_{i+1}\; |\; E_{i+1}\; |\; C_i
        }
    \]
    
    \caption{Termination assertion generation rules,
             continiued from \autoref{fig:terminationassertiongen}}
    \label{fig:terminationassertiongen2}
\end{figure}

\begin{figure}
    \centering
    \[
        \begin{array}{lr}
            \text{sumList}\; r =
                & E_1 = \alpha \leftarrow r;\; G_1 = \varnothing\; \\
                & \text{(Initialisation)} \\
                \\
            \hspace{1em}    \textsf{take}\; r'\; \{ l = l \} = r\; \textsf{in} 
                & E_2, = E_1,\; \beta \leftarrow r',\; \gamma \leftarrow l;  \\
                & G_2 = G_1,\; \alpha \teq \beta,\; \gamma \tlt \beta \\
                & \textsc{\footnotesize (T-Take)}\\

            \hspace{2em}    \textsf{case}\; l\; \textsf{of} \\
            \hspace{3em}        \text{Nil}\; u\; \rightarrow\; 0 \\
            \hspace{3em}    |\; v2 \rightarrow 
                & E_3 = E_2,\; u \leftarrow \delta,\; \eta \leftarrow v2; \\
                & G_3 = G_2,\; \delta \tlt \gamma,\; \eta \teq \gamma \\
                & \textsc{\footnotesize (T-Case)}\\
                \\
            \hspace{4em}    \textsf{case}\; v2\; \textsf{of} \\
            \hspace{5em}    \text{Cons}\; s\; \rightarrow 
                & E_4 = E_3,\; \phi \leftarrow s \\
                & G_4 = G_3,\; \phi \tlt \eta \\
                & \textsc{\footnotesize (T-CaseIrr)} \\
                \\
            \hspace{6em}    \textsf{take}\; s'\; \{ rest = r \} = s\; \textsf{in} \hspace{2em}
                & E_5 = E_4,\; \psi \leftarrow s',\; \pi \leftarrow r;  \\
                & G_5 = G_4,\; \psi \teq \phi,\; \pi \tlt \psi  \\
                & \textsc{\footnotesize (T-Take)} \\
                \\
            \hspace{7em}        s.data\; +\; \text{sumList}\; r
                & C = \{\pi\}\\
                & \textsc{\footnotesize (T-FApp)}\\
            \hspace{6em}    \textsf{end} \\
            \hspace{4em}    \textsf{end} \\
            \hspace{2em}    \textsf{end} \\
            \hspace{1em}    \textsf{end};
        \end{array}
    \]
    Final termination assertion generator output:
    \[
        G' = \{\;
            \alpha \teq \beta,\;
            \gamma \tlt \beta,\;
            \delta \tlt \gamma,\;
            \eta \teq \gamma,\;
            \phi \tlt \eta,\;
            \psi \teq \phi,\;
            \pi \tlt \psi\;
        \}
    \]
    \[
        C = \{\pi\}    
    \]

    
    \caption{An example of generated termination assertions on a program
             that sums a list of integers}
    \label{fig:exampletermination}
\end{figure}

\begin{figure}
    \centering
    \begin {tikzpicture}[-latex, auto, node distance = 1.5 cm and 2cm, on grid,
                         semithick, state/.style =
                            {
                                circle, draw, black, minimum width = 0.9 cm
                            }
                        ]
        % Vertices
        \node[state] (A)                       {$\alpha$};
        \node[state] (B)  [right = of A]       {$\beta$};
        \node[state] (G)  [right = of B]       {$\gamma$};
        \node[state] (D)  [below right = of G] {$\delta$};
        \node[state] (E)  [right = of G]       {$\eta$};
        \node[state] (PH) [right = of E]       {$\phi$};
        \node[state] (PS) [right = of PH]      {$\psi$};
        \node[state] (PI) [right = of PS]      {$\pi$};

        % Edges
        \path (A) edge[bend right = 20] node{} (B);
        \path (B) edge[bend right = 20] node{} (A);

        \path (B) edge node{} (G);

        \path (G) edge node{} (D);

        \path (G) edge[bend right = 20] node{} (E);
        \path (E) edge[bend right = 20] node{} (G);

        \path (E) edge node{} (PH);

        \path (PH) edge[bend right = 20] node{} (PS);
        \path (PS) edge[bend right = 20] node{} (PH);

        \path (PS) edge node{} (PI);

    \end{tikzpicture}
    
    \caption{The graph constructed from the assertions generated in \autoref{fig:exampletermination}}
    \label{fig:terminationgraph}
\end{figure}

\FloatBarrier

To determine whether our function terminates, we construct a directed graph from
our assertions, where variable names are vertices and edges are the relations
between them. For example, $\alpha \tlt \beta$ would produce a directed edge from
$\beta$ to $\alpha$, and $\alpha \teq \beta$ would produce a bidirectional edge between 
$\alpha$ and $\beta$. To show termination, we show that there is a one-way path
from the argument node to every goal node.

As an example, consider our earlier list sum example in \autoref{fig:exampletermination}
that features inline generated termination constraints. Note that our program also shadows
the variable $r$ in the last \textsf{take} statement, which the termination
rules generate a different fresh name for. Using our final set of assertions
$G'$ and our goal set $C$ we must show that $\pi \tlt \alpha$.
Using our assertions we construct the graph in \autoref{fig:terminationgraph}
and observe the following path from $\alpha$ to $\pi$:

\[
    \alpha \rightarrow \beta \rightarrow \gamma \rightarrow
    \eta   \rightarrow \phi  \rightarrow \psi   \rightarrow
    \pi
\]

We also observe that there are no outgoing edges from $\pi$, therefore there is no return path
to $\alpha$ and hence our path is one-way. Thus, our example function terminates.

\subsection{Possible Future Improvements}

Earlier, we discussed the problem of only being able to reason about expressions that are
program variables. Our partial solution currently simply eliminates the assertions that
do not reason solely about program variables, however we seek a more complete way to solve
this problem.

One potential idea is to eliminate structural size inequality ($\tlt$), and preserve relative
size information by using only discrete size changes. Consider our earlier example $x \tlt C\; y$,
where we were unable to remove the constructor $C$ from $y$. 
If earlier when generating this assertion we wrote  $x - 1 \teq C\; y$,
where $x - 1$ means `1 structural size less than $x$', we would be able to know exactly
how much structurally smaller $x$ is than $y$. If we wanted to simplify this assertion,
we could do so by removing the constructor $C$ from $y$, and then taking away one structural size from
the LHS of the assertion, leaving $x - 2 \teq y$.

Not only does this allow us to use extra assertions, but we may still determine 
if our function terminates by showing existance of a one-way path from the input
argument to recursive call arguments. We simply normalise all equations into the
form $x - C \teq y$, where $x$ and $y$ are variables and $C$ is a constant, and
then create a directed path from $y$ to $x$ if $C \neq 0$, and a bidirectional
path between $x$ and $y$ if $C = 0$.

Unfortunately, Cogent integer literals \textsc{U8}, \textsc{U16}, \textsc{U32} and
\textsf{U64} are not structural types, and hence terminating recursion on integers
cannot be detected via our current method. Furthermore, as unsigned integer
overflow is permitted in our Cogent programs, even basic structural integer
recursion could produce a non-terminating program, as a program that takes
away from an integer recursively with no base case can infinitely underflow.

A potential solution to this problem could be to map unsigned integers
and literals to a Peano natural number representation, and require that
each program has an expression with a base case for any recursive call
on integers, and performs recursion by taking only one constructor
away per recursive call, so it does not `skip' a base case.

As a thesis extension, we have defined termination checking and provided
a pen-and-paper formalisation. As future work, termination checking can be
the adapted and implemented in the full compiler and in Minigent, and then
the generation of an Isabelle/HOL termination proof from the results
of the termination checker.

\section{Conclusion}

Our proposed work has satisfied our three major requirements: type-safe recursive types,
maintaining the existing type system benefits that Cogent's type system provides,
and ease of showing termination.

Our design allows for the flexible creation of recursive types on top of Cogent's existing
boxed records, which prevent type-incorrect programs from being permitted by Cogent's
constraint solver. Our examples show that we can create data structures such as lists
and trees, and implement functions such as \textsf{map} to operate on them. Cogent's
uniqueness type guarantees are maintained as our recursive types do not alter the existing
constraint generation rules or solver rules, but rather only add more constraints.
This will in future allow the optimisations and high level embedding
that Cogent currently has in the main compiler to remain unchanged
when porting recursive types from Minigent.

Our extension work for formalising a termination check within Cogent has set the groundwork
to ensure that Cogent programs are total and terminating. While the design has room for
improvement, the current formalised rules already provide the basis for an implementation
in Minigent and then in the full compiler. Using an opt-out mechanism in the language,
programmers would be allowed to express more complex functions if they choose while being reminded
of potential non termination by the compiler, giving them an increased awareness
of the termination proof awaiting in the embedding.