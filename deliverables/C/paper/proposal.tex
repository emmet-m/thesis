\chapter{Completed Work}\label{ch:style}

Considering our investigation, we have expanded upon the existing Cogent infrastructure keeping in mind
three major requirements: the ability for programmers to create recursive, iterable data structures via
recursive types, the necessity for our programs to be easily proven \textit{total},
and the preservation of the benefits guaranteed by Congent's uniqueness types system.

Our proposed design has been implemented in \textit{Minigent}, a stripped down version of Cogent that
features only the type checking component of Cogent in order to focus on integrating smoothly with the 
existing project. This also allows us to focus on the design of our recursive types without having to change
the C code generation and Isabelle embedding of Cogent.

Work has been completed to incorporate our proposed design into the parsing, lexing, reorganising and 
typechecking compiler phases of Minigent, with a rough design of a potential termination checking extension.
In addition to the existing suite of tests in the Minigent typechecker, additional tests have 
been added to test the newly added recursive types.

\todo{Make sure the below addresses the above `three major requirements'}

\section{Grammar and Syntax}

\begin{figure}
    \centering
    \begin{align*}
        \text{types } \tau
            ::= \dots\; &|\; \mu\; \{ \overline{f_i^u\; \tau_i} \} \\
                        &|\; t_r \\
        \text{recursive parameters }\mu ::&= \textbf{mu}\; t\; |\; \varepsilon
    \end{align*}
    \caption{Extending our record syntax with recursive parameters}
    \vspace{2em}
    \label{fig:mu}
\end{figure}

\begin{figure}
    \centering
    \begin{tabular}{l}
        \textbf{type} List = \textbf{mu} $t$ \{ \\
            \phantom{x}\hspace{2em}\textit{l}: $\langle\;$ \\
            \phantom{x}\hspace{4em} $\text{Cons } (t,\textsc{U32})\;$ \\
            \phantom{x}\hspace{3.7em}$|\; \text{Nil } ()\;$ \\
            \phantom{x}\hspace{2em}$\rangle$ \\
        \} 
    \end{tabular}
    \vspace{2em}
    \caption{Constructing the List datatype using recursive parameters}
    \label{fig:muexample}
\end{figure}

We have extended the existing record grammar with an optional recursive parameter \textbf{mu} as in
\autoref{fig:mu} to add recursive type parameters to Cogent's boxed records, and enabled the use
of recursive parameter variables in the language.

Boxed records now feature an optional recursive type variable bound by the \textbf{mu} keyword, which may
feature in a record type in which they are bound. This also our new record syntax to be backwards
compatible with the previous record syntax, enabling existing Cogent programs to remain unchanged.

\autoref{fig:muexample} demostrates the use of our new grammar to construct an integer list datatype,
with the use of a variant type in a recursive record field \textit{l} that is either Nil,
the end of the list, or Cons, the current integer and the rest of the list.

\todo{more examples here? Maybe at the end of this chapter?}

\section{Strictly Positive Types}

\begin{figure}
    \centering
    \begin{gather*}
    \infer[\textsc{sp-rec}]{
        \mathcal{S}; \mathcal{B} \vdash \mu\; \{\overline { f_i : \tau_i } \} \textbf{ SP}
    }{
        \forall \tau_i.\; \mathcal{S}\setminus \textbf{RP}(\mu), \mathcal{B} \cup \textbf{RP}(\mu) \vdash \tau_i \textbf{ SP}
    }
    \hspace{3em}
    \begin{split}
        \textbf{RP}(\textbf{mu } t) &= \{t\} \\
        \textbf{RP}(\varepsilon) &= \{\}
    \end{split} \\[10pt]
    \infer[\textsc{sp-var}]{
        \mathcal{S}; \mathcal{B} \vdash \langle\overline{\kappa_i : \tau_i}\rangle \textbf{ SP}
    }{
        \forall \tau_i.\; \mathcal{S}; \mathcal{B} \vdash \tau_i \textbf{ SP}
    }
    \hspace{3em}
    \infer[\textsc{sp-func}]{
        \mathcal{S}; \mathcal{B} \vdash \tau_1 \rightarrow \tau_2 \textbf{ SP}
    }{
        \mathcal{S} \cup \mathcal{B}; \mathcal{B} \vdash \tau_1 \textbf{ SP}
        &
        \mathcal{S}; \mathcal{B} \vdash \tau_2 \textbf{ SP}
    } \\[10pt]
    \infer[\textsc{sp-rvar}]{
        \mathcal{S}; \mathcal{B} \vdash t_r \textbf{ SP}
    }{
        t_r \notin \mathcal{S}
    }
    \hspace{2em}
    \infer[\textsc{sp-prim}]{
        \mathcal{S}; \mathcal{B} \vdash \mathcal{T} \textbf{ SP}
    }{}
    \hspace{2em}
    \infer[\textsc{sp-tvar}]{
        \mathcal{S}; \mathcal{B} \vdash a \textbf{ SP}
    }{}
    \end{gather*}
    \caption{The rules for checking that Cogent types are strictly positive}
    \label{fig:strictlypositivecheck}
\end{figure}

Checking that all types occur only strictly positive has been implemented in the reorganisation phase of the compiler
instead of during type checking. This allows for a simple one-pass algorithm to analyse all the types in the program
at once, and a simpler contraint generation and solving phases.

\autoref{fig:strictlypositivecheck} describes the strictly positive check over Cogent's types.
This algorithm keeps track of a set of in scope bound recursive parameters $\mathcal{B}$ and a set of recursive
parameters currently in a non-strictly positive position $\mathcal{S}$.

Rule \textsc{sp-rec} describes checking a record bound with a recursive parameter $t$, where parameter 
is added to the bound set $\mathcal{B}$, and removed from the non-strictly positive set $\mathcal{S}$
(as these variables can shadow previous variables), where $\textbf{RP}(\mu)$ returns the recursive
parameter variable in $\mu$ if it has one.

Rule \textsc{sp-func} describes checking a function type, where checking the argument position $\tau_1$ adds
all currently bound ($\mathcal{B}$) parameters to the non-strictly positive set ($\mathcal{S}$), and then
checking the result position $\tau_2$.

Rule \textsc{sp-rvar} describes checking a recursive parameter variable $t_r$, requiring that it is not currently
in a non-strictly positive position (i.e. not in the $\mathcal{S}$ set). 

\textsc{sp-var} merely descends on the types nested within a variant,
\textsc{sp-prim} allows for primitive types ($\mathcal{T}$) and
\textsc{sp-tvar} allows for type variables ($a$).

Once strictly positive typing is checked, the reorganiser will embed all used recursive parameter variables
with a reference to the recursive boxed record that they were bound to, which is used during the constraint
solving phase.

\section{Typing and Constraint Generation Rules}

% Unboxed Not Recursive check
\begin{figure}
    \centering
    $$
        \infer{
            \mu \text{ \textcircled{u} } \textbf{UnboxedNotRecursive}
        }{
            \mu = \varepsilon
        }
    $$
    $$
        \infer{
            (\textbf{mu } t) \text{ s } \textbf{UnboxedNotRecursive}
        }{
            s \neq \text{\textcircled{u}}
        }
    $$
    \caption{A constraint checking that recursive parameters are used only with boxed records}
    \label{fig:unboxednotrecursive}
\end{figure}

% PUT typing rule
\begin{figure}
    \centering
    \begin{align*}
        \infer[\textsc{\footnotesize{Put}}]{
            A;\Gamma \vdash \textsf{put } e_1.f_k  = e_2 : \; \mu \; \{ \overline{f_i^u : \tau_i}, f_k^\circ : \tau_k \} s
        }{
            \begin{array}{c}
                A;\Gamma \vdash e2 : \tau_k
                \hspace{2em}
                A \vdash \Gamma \rightsquigarrow \Gamma_1 \boxplus \Gamma_2
                \hspace{2em}
                s \neq \text{\textcircled{r}}
                \vspace{0.5em} \\
                A;\Gamma_1 \vdash e_1\; : \mu\; \{ \overline{f_i^u : \tau_i}, f_k^\bullet : \tau_k \}\; s
                \vspace{0.5em} \\
                A \vdash \mu \textit{ s } \textbf{UnboxedNotRecursive}
            \end{array}
        }
    \end{align*}
    
    \caption{The updated typing rule for \textsc{put}}
    \label{fig:puttypingrule}
\end{figure}

% TAKE typing rule
\begin{figure}
    \centering
    \begin{align*}
        \infer[\textsc{\footnotesize{Take}}]{
            A;\Gamma \vdash \textsf{take } r \{ f_k = y \} = e1 \textsf{ in } e_2 : \tau
        }{
            \begin{array}{c}
                A \vdash \Gamma \rightsquigarrow \Gamma_1 \boxplus \Gamma_2
                \hspace{3em}
                A;\Gamma_1 \vdash e_1\; : \mu\; \{ \overline{f_i^u : \tau_i}, f_k^\circ : \tau_k \}\; s
                \vspace{0.5em} \\
                A \vdash \mu \textit{ s } \textbf{UnboxedNotRecursive}
                \hspace{3em}
                s \neq \text{\textcircled{r}}
                \vspace{0.5em} \\
                A; r : \mu\; \{ \overline{f_i^u : \tau_i}, f_k^\bullet : \tau_k \}\; s
                ,\; y : \tau_k,\; \Gamma_2 \vdash e_2 : \tau
            \end{array}
        }
    \end{align*}
    
    \caption{The updated typing rule for \textsc{take}}
    \label{fig:taketypingrule}
\end{figure}

% MEMBER typing rule
\begin{figure}
    \centering
    \[
        \infer[\textsc{\footnotesize{Member}}]{
            A;\Gamma \vdash e.f_k : \tau
        }{
            A;\Gamma \vdash e : \mu\; \{ \overline{f_i^\bullet : \tau_i}, f_k^\circ : \tau_k \}\; s
            &\hspace{1em}
            A \vdash \mu \textit{ s } \textbf{UnboxedNotRecursive}
        }
    \]
    
    \caption{The updated typing rule for \textsc{Member}}
    \label{fig:membertypingrule}
\end{figure}

% MEMBER constraint gen rule
\begin{figure}
    \centering
    \[
        \infer[\textsc{\footnotesize{CG-Member}}]{
            G \vdash e.f_k : \tau_k \rightsquigarrow G'\; |\; C_1 \land C_2 \land C_3
        }{
            \begin{array}{c}
                \alpha, \beta, \gamma\; \text{fresh}
                \hspace{2em}
                G \vdash e : \gamma\; \{ f^\circ : \tau | \alpha \}\; \beta \rightsquigarrow G'\; |\; C_1 \\[5pt]
                C_2 = \gamma\; \{ f^\bullet : \tau | \alpha \}\; \beta\; \textbf{Drop}
                \hspace{2em}
                C_3 = \gamma\; \beta\; \textbf{UnboxedNotRecursive}
            \end{array}
        }
    \]
    
    \caption{The updated constraint generation rule for \textsc{Member}}
    \label{fig:memberconstraintgen}
\end{figure}

% TAKE constraint gen rule
\begin{figure}
    \centering
    \[
        \infer[\textsc{\footnotesize{CG-Take}}]{
            G_1 \vdash \textsf{take } x\; \{ f = y \} = e_1 \textsf{ in } e_2
                : \tau \rightsquigarrow G_3 | \bigwedge_{k \in 1..6} C_k
        }{
            \begin{array}{c}
                \alpha, \beta, \gamma, \delta \text{ fresh}
                \hspace{1em}
                G_1 \vdash e : \delta\; \{ f^\circ : \beta\; |\; \alpha \}\;
                    \gamma \rightsquigarrow G_2\; |\; C_1 \\[7pt]
                x :_{\langle 0 \rangle} \delta \{ f^\bullet : \beta | \alpha \} \gamma,\;
                    y :_{\langle 0 \rangle} \beta,\;
                    G_2 \vdash e_2 : \tau 
                     \rightsquigarrow     
                    x :_{\langle n \rangle} \delta \{ f^\bullet : \beta | \alpha \} \gamma,\;
                    y :_{\langle m \rangle} \beta,\;
                    G_3\; |\; C_2 \\[7pt]
                C_3 = \text{if } n = 0 \text{ then } 
                    \delta\; \{ f^\bullet : \beta\; |\; \alpha\; \}\; \gamma \textbf{ Drop}
                    \text{ else } \top \\[5pt]
                C_4 = \text{if } m = 0 \text{ then } 
                    \beta \textbf{ Drop}
                    \text{ else } \top \\[5pt]
                C_5 = \gamma \neq \text{\textcircled{r}}
                \hspace{2em}
                C_6 = \delta\; \gamma \textbf{ UnboxedNotRecursive}
            \end{array}
        }
    \]
    
    \caption{The updated constraint generation rule for \textsc{Take}}
    \label{fig:takeconstraintgen}
\end{figure}

% PUT constraint gen rule
\begin{figure}
    \centering
    \[
        \infer[\textsc{\footnotesize{CG-Put}}]{
            G_1 \vdash \textsf{put } e_1.f_k = e_2 : \tau_k \rightsquigarrow G_3\; 
                |\; \bigwedge_{k \in 1..5} C_k
        }{
            \begin{array}{c}
                \alpha, \beta, \gamma, \delta \text{ fresh}
                \hspace{2em}
                G_1 \vdash e_1 : \delta\; \{ f^\bullet: \tau | \alpha \}\; 
                    \gamma \rightsquigarrow G_2\; |\; C_1 \\[5pt]
                G_2 \vdash e_2 : \beta \rightsquigarrow G_3\; |\; C_2
                \hspace{2em}
                C_3 =  \delta\; \{ f^\circ : \tau | \alpha \}\; 
                    \gamma \subtype \tau
                \hspace{2em}
                C_4 = \gamma \neq \text{\textcircled{r}} \\[5pt]
                C_5 = \delta\; \gamma \textbf{ UnboxedNotRecursive}
            \end{array}
        }
    \]
    
    \caption{The updated constraint generation rule for \textsc{Put}}
    \label{fig:putconstraintgen}
\end{figure}


\todo{Should I talk about my previous attempt and how it failed?}


Our typing rules and Constraint generation rules have only been changed only to check one extra
constraint on records - that recursive parameters are only used on boxed records. The check for this
new constraint is outlined in \autoref{fig:unboxednotrecursive}

We modify the original \textsc{Take}, \textsc{Put} and \textsc{Member} typing rules defined by
\citet{LiamThesis} to include this constraint as in \autoref{fig:puttypingrule},
\autoref{fig:taketypingrule} and \autoref{fig:membertypingrule}.

Next, we modify the \textsc{CG-Member}, \textsc{CG-Take} and \textsc{CG-Put} for constraint generation,
where our new constraint will be produced, as in \autoref{fig:takeconstraintgen}, 
\autoref{fig:putconstraintgen} and \autoref{fig:memberconstraintgen}, to also include this
new constraint.

Each of these rules additionally now includes an extra fresh unification variable, which is
used to infer the recursive parameter of a given record. These variables are substituted
for real recursive parameters during the constraint solver's \textit{unify} phase.

\section{Constraint Solver Rules}

\begin{figure}
    \centering
    \begin{align}
       t_r  &\subtype \tau  & \simp  && \textbf{unroll } t_r  &\subtype  \tau \\
       \tau &\subtype t_r   & \simp  && \tau                  &\subtype  \textbf{unroll } t_r \\
       t_r  &\typeeq  \tau  & \simp  && \textbf{unroll } t_r  &\typeeq   \tau \\
       \tau &\typeeq  t_r   & \simp  && \tau                  &\typeeq   \textbf{unroll } t_r \\
       t_r  &\typeeq  k_r   & \simp  && \textbf{unroll } t_r  &=         \textbf{unroll } k_r \\
       t_r  &\subtype k_r   & \simp  && \textbf{unroll } t_r  &=         \textbf{unroll } k_r \\
       (\textbf{mu } t)\; &s\; \textbf{UnboxedNotRecursive}   
            & \simp &&  s = \text{\textcircled{r}} &\lor s = \text{\textcircled{w}} \\
       \varepsilon\; &\text{\textcircled{u}}\; \textbf{UnboxedNotRecursive}   
            & \simp &&  &\varepsilon
    \end{align}
    \caption{The new simplification rules}
    \label{fig:simprules}
\end{figure}

\begin{figure}
    \centering
    \[
        \textbf{unroll } t_r = \textbf{mu } t\; \{\; \dots\; \} 
    \]
    \todo{A real definition (need ideas on how)}
    \caption{the \textbf{unroll} operator}
    \label{fig:unrolldef}
\end{figure}

The constraint solver now contains additional rules in order to reason about recursive
records, which have changed the \textit{simplify} and \textit{unify}
constraint solving phases.

\subsection{Simplify Phase}

In the simplify phase, the rules described in \autoref{fig:simprules} allow for
the solver to reason about recursive types type the comparison constraints
subtyping ($\subtype$) and type equality ($\typeeq$). Rules 3.1 to 3.4 state that
when a recursive type $t_r$ is directly compared against a type $\tau$, the solver
can \textbf{unroll} $t_r$, as defined in \autoref{fig:unrolldef}.
Additionally, rules 3.5 and 3.6 cover the case where we compare two recursive parameters
$t_r$ and $k_r$, where we check that \textbf{unroll}ing both parameters results
in the same type.

Rules 3.7 and 3.8 allow for the elmination of \textbf{UnboxedNotRecursive} constraints
given that either the recursive parameter is nothing ($\varepsilon$) and the sigil is
unboxed (\textcircled{u}), or that the recursive paremeter is some \textbf{mu} $t$ and
the accompanying sigil $s$ is readonly (\textcircled{r}) or writable (\textcircled{w}).

\subsection{Unify Phase}

The unify phase now unifies unknown recursive parameters that are embedded
on records. Given constraints of the form 
$\alpha\; \{ \dots \} \subtype \mu\; \{ \dots \}$ or of the form
$\alpha\; \{ \dots \} \typeeq \mu\; \{ \dots \}$, where $\alpha$ is a unification
variable and $\mu$ is a concrete recursive parameter, we can simply replace all
$\alpha$ with $\mu$ without an occurs check, and add the substitution 
$\alpha := \mu$ to our set of assignments that the solver will output. 
This is true symmetrically, when the left and right hand sides of the above
constraints are swapped.

The unify phase also now unifies recursive parameters in an \textbf{UnboxedNotRecursive}
constraint to nothing ($\varepsilon$) if the sigil in that constraint has been unified to
an unboxed sigil (\textcircled{u}). If this unification variable was meant to be a recursive
parameter ($t_r$), then the constraint solving will fail elsewhere due to this substitution,
preserving the correctness of the solver.

\section{Termination}

A primitive recursion detection scheme has been designed to check the termination
of functions that structurally recurse on our new recursive types. This introduces
a new phase into the compiler; the \textit{termination checker}.

\subsection{Design}

Our new termination checker works by generating assertions about the structural
size of variables passed to the function, and when any recursive calls are made 
uses these assertions to check that the structural size of the argument to the
recursive call is strictly smaller than that of the function argument, i.e. the argument
given to a recursive call will only ever grow smaller, and hence the function will
eventually reach the `bottom' of the structure and terminate.
As all recursive types constructed must be finite due to our use of strictly positive
types and Cogent's linear type system (no infinitely looping structures),
all primitive recursive calls will terminate.

Our size assertions take the form of 2 relations between variables, $\tlt$ anb $\teq$.
$x \tlt y$ is the assertion that a variable $x$ is strictly
structurally smaller than a varialbe $y$ and, $x \teq y$ is the assertion that a
varialbe $x$ is structurally equal in size to a variable $y$.

The checker starts with a set of known termination assertions $G$, and then adds
extra assertions by analysing the expression body of a function to produce
a stronger set of assertions $G'$, as well as a set of expressions that are arguments
to recursive function calls $C$. \autoref{fig:terminationcondition} describes the
condition for soundness of our termination checker. Completeness for the termination
checker is impossible as a consequence of the halting problem, and thus the checker
does not attempt to check more than primitive recursion.

\begin{figure}
    \centering
    \[
        \begin{array}{ll}
            f\; a = e              
                & \begin{array}{l}
                    \textit{Given a function definition}
                  \end{array} \\[10pt]
            \implies E; G \vdash e \rightsquigarrow G'\; |\; E\; |\; C
                & \begin{array}{l}
                    \textit{and a set of assertions and 
                        goal expressions} \\
                    \textit{generated by the assertion generator} \\[10pt]
                  \end{array} \\[10pt]
            \implies G' \vdash \forall e' \in C.\; e' \tlt a
                & \begin{array}{l}
                    \textit{The function terminates if every goal } \\
                    \textit{expression is smaller than the function} \\
                    \textit{argument under the produced assertions}
                  \end{array}
        \end{array}
    \]
    
    \caption{The termination checker soundness condition}
    \label{fig:terminationcondition}
\end{figure}

We generate such assertions by looking at Cogent's expression langauge 
where any form of structural size is added or taken away, namely
\textsf{take}, \textsf{put} and \textsf{case} expressions.
\autoref{fig:terminationassertiongen} describes this assertion generation.

As program variables can be shadowed, we may end up with a set of impossible assertions
by using raw variable names. To overcome this, we generate a fresh variable name for each
program variable.
We store this mapping of fresh variable names in a context $E$, which we update as we encounter
variable definitions in the function expression.

With our current method of size relations, we are unable to reason about raw program variables
comapared against any general expression. For example, suppose the assertion $x \tlt C\; y$.
This assertion is useless to us as we have no way of reasoning about $x$ and $y$ directly,
and we are unable to remove the constructor $C$ as we have no information about the
gap in size beteen $x$ and $y$. We could have $x \tlt y$ if x is more than 1 layer
of structure smaller than y, or $x \teq y$ if x is only 1 layer of structure smaller.

To overcome this, 
we define a function \textsf{get} in \autoref{fig:getdef} that maps an expression to
a fresh variable name if the expression is a program variable and otherwise nothing.

\begin{figure}
    \centering
    \[
        \textsf{get}(E, e) = \textsf{if } e = t \textsf{ then } E[t] \textsf{ else } \varepsilon
    \]
    
    \caption{The definition of \textsf{get}}
    \label{fig:getdef}
\end{figure}

After generating all of our assertions, we filter out any assertions that include a nothing ($\varepsilon$),
as we cannot reason about them in any way, or fail if any goal contains a nothing. While this solution may
not be as complete as it possibly could, it allows us to use our assertions to prove termination.

\begin{figure}
    \centering
    \[
        \fbox{$G \vdash e : \tau \rightsquigarrow G'\; |\; E\; |\; C$}
    \]
    \[
        \infer[\textsc{\footnotesize T-Take}]{
            E_1; G_1 \vdash \textsf{take } r'\; \{ f = x \} = e_1 \textsf{ in } e_2
                \rightsquigarrow G_3\; |\; E_3\; |\; C_1 \cup C_2
        }{
            \begin{array}{c}
            \alpha, \beta\; \textsf{fresh}
            \hspace{1em}
            E_1; \alpha \tlt \textsf{get}(e_1),\; \textsf{get}(e_1) \teq \beta,\; G_1 \vdash e_1
                \rightsquigarrow G_2\; |\; E_2\; |\; C_1 \\[5pt]
            E_2; G_2 \vdash e_2 \rightsquigarrow G_3\; |\; E_3\; |\; C_2
            \end{array}
        }
    \]
    \vspace{0.5em}
    \[
        \infer[\textsc{\footnotesize T-Put}]{
            E_1; G_1 \vdash \textsf{put } e_1.f := e_2
                \rightsquigarrow G_3\; |\; E_3\; |\; C_1 \cup C_2
        }{
            \begin{array}{c}
                \alpha, \beta\; \textsf{fresh}
                \hspace{1em}
                E_1; \alpha \tlt \beta,\; \beta \teq \textsf{get}(e_1),\; \alpha \teq \textsf{get}(e_2),\; 
                    G_1 \vdash e_1 \rightsquigarrow G_2\; |\; E_2\; |\; C_1 \\[5pt]
                E_2; G_2 \vdash e_2 \rightsquigarrow G_3\; |\; E_3\; |\; C_2
            \end{array}
        }
    \]
    \vspace{0.5em}
    \[
        \infer[\textsc{\footnotesize T-Case}]{
            G_1 \vdash \textsf{case } e_1 \textsf{ of } \kappa\; e_2
                \rightsquigarrow G_3\; |\; C_1 \cup C_2
        }{
            \alpha, \beta\; \textsf{fresh}
            \hspace{1em}
            \alpha \tlt \beta, \alpha \teq \textsf{get}(e_2), \beta \teq \textsf{get}(e_1)\; G_1 \vdash e_1 \rightsquigarrow G_2\; |\; C_1
            \hspace{1em}
            G_2 \vdash e_2 \rightsquigarrow G_3\; |\; C_2
        }
    \]
    \vspace{0.5em}
    \[
        \infer[\textsc{\footnotesize T-Member}]{
            G_1 \vdash e.f
                \rightsquigarrow G_2\; |\; C
        }{
            G_1 \vdash e_1 \rightsquigarrow G_2\; |\; C
        }
    \]
    \vspace{0.5em}
    \[
        \infer[\textsc{\footnotesize T-Con}]{
            G_1 \vdash \kappa\; e
                \rightsquigarrow G_2\; |\; C
        }{
            G_1 \vdash e_1 \rightsquigarrow G_2\; |\; C
        }
        \hspace{1em}
        \infer[\textsc{\footnotesize T-TApp}]{
            G \vdash f\textbf{[}\harpoon{\tau_i}\textbf{]}
                \rightsquigarrow G\; |\; \varnothing
        }{
        }
    \]
    \vspace{0.5em}
    \[
        \infer[\textsc{\footnotesize T-FApp}]{
            G_1 \vdash e_1\; e_2
                \rightsquigarrow G_3\; |\; C_1 \cup C_2 \cup \{e_2\}
        }{
            G_1 \vdash e_1 \rightsquigarrow G_2\; |\; C_1
            \hspace{1em}
            G_2 \vdash e_2 \rightsquigarrow G_3\; |\; C_2
        }
    \]
    \vspace{0.5em}
    \[
        \infer[\textsc{\footnotesize T-TVar}]{
            G \vdash x
                \rightsquigarrow G\; |\; \varnothing
        }{}
        \hspace{1em}
        \infer[\textsc{\footnotesize T-Lit}]{
            G \vdash \ell
                \rightsquigarrow G\; |\; \varnothing
        }{}
    \]
    \vspace{0.5em}
    \[
        \infer[\textsc{\footnotesize T-PrimOp}]{
            G_1 \vdash e_1 \text{ \textasteriskcentered }\; e_2
                \rightsquigarrow G_3\; |\; C_1 \cup C_2
        }{
            G_1 \vdash e_1 \rightsquigarrow G_2\; |\; C_1
            \hspace{1em}
            G_2 \vdash e_2 \rightsquigarrow G_3\; |\; C_2
        }
    \]
    \vspace{0.5em}
    \[
        \infer[\textsc{\footnotesize T-Let}]{
            G_1 \vdash \textsf{let } x = e_1 \textsf{ in } e_2
                \rightsquigarrow G_3\; |\; C_1 \cup C_2
        }{
            \alpha \; \textsf{fresh}
            \hspace{1em}
            G_1 \vdash e_1 \rightsquigarrow G_2\; |\; C_1
            \hspace{1em}
            \alpha \teq \textsf{get}(e_1),\; G_2 \vdash e_2 \rightsquigarrow G_3\; |\; C_2
        }
    \]
    \vspace{0.5em}
    \[
        \infer[\textsc{\footnotesize T-If}]{
            G_1 \vdash \textsf{if } e_1 \textsf{ then } e_2 \textsf{ else } e_3
                \rightsquigarrow G_4\; |\; C_1 \cup C_2 \cup C_3
        }{
            G_1 \vdash e_1 \rightsquigarrow G_2\; |\; C_1
            \hspace{1em}
            G_2 \vdash e_2 \rightsquigarrow G_3\; |\; C_2
            \hspace{1em}
            G_3 \vdash e_3 \rightsquigarrow G_4\; |\; C_3
        }
    \]
    \vspace{0.5em}
    \[
        \infer[\textsc{\footnotesize T-Tysig}]{
            G_1 \vdash e :: \tau
                \rightsquigarrow G_2\; |\; C
        }{
            G_1 \vdash e \rightsquigarrow G_2\; |\; C
        }
        \hspace{1em}
        \infer[\textsc{\footnotesize T-Struct}]{
            G_1 \vdash \{\overline{f_i = e_i}\}
                \rightsquigarrow G_{n+1}\; |\; \bigcup_{i = 1}^n C_i
        }{
            \forall i \in [1..n].\; G_i \vdash e_i \rightsquigarrow G_{i+1}\; |\; C_i
        }
    \]

    \caption{Termination assertion generation rules}
    \label{fig:terminationassertiongen}
\end{figure}

To determine whether a function terminates, we put our assertions and goals into an
\textit{integer linear programming} solver, which finds a valid number substitution to every
assertion such that they are all true. If such a substitution exists, then the function terminates.
Otherwise, we know nothing about the function terminating.

\todo{example}

\subsection{Possible Future Improvements}

Earlier, we discussed the problem of only being able to reason about expressions that are
program variables. Our partial solution currently simply eliminates the assertions that
do not reason solely about program variables, however we seek a more complete way to solve
this problem.

One potential idea is to eliminate structural size inequality ($\tlt$), and preserve relative
size information by talking about discrete size changes. Consider our earlier example $x \tlt C\; y$,
where we were unable to remove the constructor $C$ from $y$. 
If earlier when generating this assertion we wrote  $x - 1 \teq C\; y$,
where $x - 1$ means `1 structural size less than $x$', we would be able to know exactly
how much structurally smaller $x$ is than $y$. If we wanted to simplify this assertion,
we could do so by removing the constructor $C$ from $y$, and then taking away one structural size from
the LHS of the assertion, leaving $x - 2 \teq y$.

Not only does this allow us to use this assertion, but we can still use integer linear programming to
solve the series of equations produced, provided all assertions still reference variables directly.
As a result, our termination checker can identify a larger set of functions that are primitive recursive.

\section{Example Usage and Testing}
