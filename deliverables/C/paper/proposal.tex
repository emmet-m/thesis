\chapter{Completed Work}\label{ch:style}

Considering our investigation, we have expanded upon the existing Cogent infrastructure keeping in mind
three major requirements: the ability for programmers to create recursive, iterable data structures via
recursive types, the necessity for our programs to be easily proven \textit{total},
and the preservation of the benefits guaranteed by Congent's uniqueness types system.

Our proposed design has been implemented in \textit{Minigent}, a stripped down version of Cogent that
features only the type checking component of Cogent in order to focus on integrating smoothly with the 
existing project. This also allows us to focus on the design of our recursive types without having to change
the C code generation and Isabelle embedding of Cogent.

Work has been completed to incorporate our proposed design into the parsing, lexing, reorganising and 
typechecking compiler phases of Minigent, with a rough design of a potential termination checking extension.
In addition to the existing suite of tests in the Minigent typechecker, additional tests have 
been added to test the newly added recursive types.

\todo{Make sure the below addresses the above `three major requirements'}

\section{Grammar and Syntax}

\begin{figure}
    \centering
    \begin{align*}
        \text{types } \tau
            ::= \dots\; &|\; \mu\; \{ \overline{f_i^u\; \tau_i} \} \\
                        &|\; t_r \\
        \text{recursive parameters }\mu ::&= \textbf{mu}\; t\; |\; \varepsilon
    \end{align*}
    \caption{Extending our record syntax with recursive parameters}
    \vspace{2em}
    \label{fig:mu}
\end{figure}

\begin{figure}
    \centering
    \begin{tabular}{l}
        \textbf{type} List = \textbf{mu} $t$ \{ \\
            \phantom{x}\hspace{2em}\textit{l}: $\langle\;$ \\
            \phantom{x}\hspace{4em} $\text{Cons } (t,\textsc{U32})\;$ \\
            \phantom{x}\hspace{3.7em}$|\; \text{Nil } ()\;$ \\
            \phantom{x}\hspace{2em}$\rangle$ \\
        \} 
    \end{tabular}
    \vspace{2em}
    \caption{Constructing the List datatype using recursive parameters}
    \label{fig:muexample}
\end{figure}

We have extended the existing record grammar with an optional recursive parameter \textbf{mu} as in
\autoref{fig:mu} to add recursive type parameters to Cogent's boxed records, and enabled the use
of recursive parameter variables in the language.

Boxed records now feature an optional recursive type variable bound by the \textbf{mu} keyword, which may
feature in a record type in which they are bound. This also our new record syntax to be backwards
compatible with the previous record syntax, enabling existing Cogent programs to remain unchanged.

\autoref{fig:muexample} demostrates the use of our new grammar to construct an integer list datatype,
with the use of a variant type in a recursive record field \textit{l} that is either Nil,
the end of the list, or Cons, the current integer and the rest of the list. Further
examples are discussed in \autoref{ch:examplesandtesting} at the end of the chapter.

\section{Strictly Positive Types}

\begin{figure}
    \centering
    \begin{gather*}
    \begin{split}
        \textbf{RP}(\textbf{mu } t) &= \{t\} \\
        \textbf{RP}(\varepsilon) &= \{\}
    \end{split} \\[10pt]
    \infer[\textsc{sp-rec}]{
        \mathcal{S}; \mathcal{B} \vdash \mu\; \{\overline { f_i : \tau_i } \} \textbf{ SP}
    }{
        \mathcal{S}\setminus \textbf{RP}(\mu), \mathcal{B} \cup \textbf{RP}(\mu) \vdash \tau_i \textbf{ SP}
    }
    \hspace{3em}
    \infer[\textsc{sp-var}]{
        \mathcal{S}; \mathcal{B} \vdash \langle\overline{\kappa_i : \tau_i}\rangle \textbf{ SP}
    }{
        \mathcal{S}; \mathcal{B} \vdash \tau_i \textbf{ SP}
    } \\[10pt]
    \hspace{3em}
    \infer[\textsc{sp-func}]{
        \mathcal{S}; \mathcal{B} \vdash \tau_1 \rightarrow \tau_2 \textbf{ SP}
    }{
        \mathcal{S} \cup \mathcal{B}; \mathcal{B} \vdash \tau_1 \textbf{ SP}
        &
        \mathcal{S}; \mathcal{B} \vdash \tau_2 \textbf{ SP}
    } \\[10pt]
    \infer[\textsc{sp-rvar}]{
        \mathcal{S}; \mathcal{B} \vdash t_r \textbf{ SP}
    }{
        t_r \notin \mathcal{S}
    }
    \hspace{2em}
    \infer[\textsc{sp-prim}]{
        \mathcal{S}; \mathcal{B} \vdash \mathcal{T} \textbf{ SP}
    }{}
    \hspace{2em}
    \infer[\textsc{sp-tvar}]{
        \mathcal{S}; \mathcal{B} \vdash a \textbf{ SP}
    }{}
    \end{gather*}
    \caption{The rules for checking that Cogent types are strictly positive}
    \label{fig:strictlypositivecheck}
\end{figure}

Checking that all types occur only strictly positive has been implemented in the reorganisation phase of the compiler
instead of during type checking. This allows for a simple one-pass algorithm to analyse all the types in the program
at once, and a simpler contraint generation and solving phases.

\autoref{fig:strictlypositivecheck} describes the strictly positive check over Cogent's types.
This algorithm keeps track of a set of in scope bound recursive parameters $\mathcal{B}$ and a set of recursive
parameters currently in a non-strictly positive position $\mathcal{S}$.

Rule \textsc{sp-rec} describes checking a record bound with a recursive parameter $t$, where parameter 
is added to the bound set $\mathcal{B}$, and removed from the non-strictly positive set $\mathcal{S}$
(as these variables can shadow previous variables), where $\textbf{RP}(\mu)$ returns the recursive
parameter variable in $\mu$ if it has one.

Rule \textsc{sp-func} describes checking a function type, where checking the argument position $\tau_1$ adds
all currently bound ($\mathcal{B}$) parameters to the non-strictly positive set ($\mathcal{S}$), and then
checking the result position $\tau_2$.

Rule \textsc{sp-rvar} describes checking a recursive parameter variable $t_r$, requiring that it is not currently
in a non-strictly positive position (i.e. not in the $\mathcal{S}$ set). 

\textsc{sp-var} merely descends on the types nested within a variant,
\textsc{sp-prim} allows for primitive types ($\mathcal{T}$) and
\textsc{sp-tvar} allows for type variables ($a$).

Once strictly positive typing is checked, the reorganiser will embed all used recursive parameter variables
with a reference to the recursive boxed record that they were bound to, which is used during the constraint
solving phase.

\section{Typing and Constraint Generation Rules}

% Unboxed Not Recursive check
\begin{figure}
    \centering
    $$
        \infer{
            \mu \text{ \textcircled{u} } \textbf{UnboxedNotRecursive}
        }{
            \mu = \varepsilon
        }
    $$
    $$
        \infer{
            (\textbf{mu } t) \text{ s } \textbf{UnboxedNotRecursive}
        }{
            s \neq \text{\textcircled{u}}
        }
    $$
    \caption{A constraint checking that recursive parameters are used only with boxed records}
    \label{fig:unboxednotrecursive}
\end{figure}

% PUT typing rule
\begin{figure}
    \centering
    \begin{align*}
        \infer[\textsc{\footnotesize{Put}}]{
            A;\Gamma \vdash \textsf{put } e_1.f_k  = e_2 : \; \mu \; \{ \overline{f_i^u : \tau_i}, f_k^\circ : \tau_k \} s
        }{
            \begin{array}{c}
                A;\Gamma \vdash e2 : \tau_k
                \hspace{2em}
                A \vdash \Gamma \rightsquigarrow \Gamma_1 \boxplus \Gamma_2
                \hspace{2em}
                s \neq \text{\textcircled{r}}
                \vspace{0.5em} \\
                A;\Gamma_1 \vdash e_1\; : \mu\; \{ \overline{f_i^u : \tau_i}, f_k^\bullet : \tau_k \}\; s
                \vspace{0.5em} \\
                A \vdash \mu \textit{ s } \textbf{UnboxedNotRecursive}
            \end{array}
        }
    \end{align*}
    
    \caption{The updated typing rule for \textsc{put}}
    \label{fig:puttypingrule}
\end{figure}

% TAKE typing rule
\begin{figure}
    \centering
    \begin{align*}
        \infer[\textsc{\footnotesize{Take}}]{
            A;\Gamma \vdash \textsf{take } r \{ f_k = y \} = e1 \textsf{ in } e_2 : \tau
        }{
            \begin{array}{c}
                A \vdash \Gamma \rightsquigarrow \Gamma_1 \boxplus \Gamma_2
                \hspace{3em}
                A;\Gamma_1 \vdash e_1\; : \mu\; \{ \overline{f_i^u : \tau_i}, f_k^\circ : \tau_k \}\; s
                \vspace{0.5em} \\
                A \vdash \mu \textit{ s } \textbf{UnboxedNotRecursive}
                \hspace{3em}
                s \neq \text{\textcircled{r}}
                \vspace{0.5em} \\
                A; r : \mu\; \{ \overline{f_i^u : \tau_i}, f_k^\bullet : \tau_k \}\; s
                ,\; y : \tau_k,\; \Gamma_2 \vdash e_2 : \tau
            \end{array}
        }
    \end{align*}
    
    \caption{The updated typing rule for \textsc{take}}
    \label{fig:taketypingrule}
\end{figure}

% MEMBER typing rule
\begin{figure}
    \centering
    \[
        \infer[\textsc{\footnotesize{Member}}]{
            A;\Gamma \vdash e.f_k : \tau
        }{
            A;\Gamma \vdash e : \mu\; \{ \overline{f_i^\bullet : \tau_i}, f_k^\circ : \tau_k \}\; s
            &\hspace{1em}
            A \vdash \mu \textit{ s } \textbf{UnboxedNotRecursive}
        }
    \]
    
    \caption{The updated typing rule for \textsc{Member}}
    \label{fig:membertypingrule}
\end{figure}

% MEMBER constraint gen rule
\begin{figure}
    \centering
    \[
        \infer[\textsc{\footnotesize{CG-Member}}]{
            G \vdash e.f_k : \tau_k \rightsquigarrow G'\; |\; C_1 \land C_2 \land C_3
        }{
            \begin{array}{c}
                \alpha, \beta, \gamma\; \text{fresh}
                \hspace{2em}
                G \vdash e : \gamma\; \{ f^\circ : \tau | \alpha \}\; \beta \rightsquigarrow G'\; |\; C_1 \\[5pt]
                C_2 = \gamma\; \{ f^\bullet : \tau | \alpha \}\; \beta\; \textbf{Drop}
                \hspace{2em}
                C_3 = \gamma\; \beta\; \textbf{UnboxedNotRecursive}
            \end{array}
        }
    \]
    
    \caption{The updated constraint generation rule for \textsc{Member}}
    \label{fig:memberconstraintgen}
\end{figure}

% TAKE constraint gen rule
\begin{figure}
    \centering
    \[
        \infer[\textsc{\footnotesize{CG-Take}}]{
            G_1 \vdash \textsf{take } x\; \{ f = y \} = e_1 \textsf{ in } e_2
                : \tau \rightsquigarrow G_3 | \bigwedge_{k \in 1..6} C_k
        }{
            \begin{array}{c}
                \alpha, \beta, \gamma, \delta \text{ fresh}
                \hspace{1em}
                G_1 \vdash e : \delta\; \{ f^\circ : \beta\; |\; \alpha \}\;
                    \gamma \rightsquigarrow G_2\; |\; C_1 \\[7pt]
                x :_{\langle 0 \rangle} \delta \{ f^\bullet : \beta | \alpha \} \gamma,\;
                    y :_{\langle 0 \rangle} \beta,\;
                    G_2 \vdash e_2 : \tau 
                     \rightsquigarrow     
                    x :_{\langle n \rangle} \delta \{ f^\bullet : \beta | \alpha \} \gamma,\;
                    y :_{\langle m \rangle} \beta,\;
                    G_3\; |\; C_2 \\[7pt]
                C_3 = \text{if } n = 0 \text{ then } 
                    \delta\; \{ f^\bullet : \beta\; |\; \alpha\; \}\; \gamma \textbf{ Drop}
                    \text{ else } \top \\[5pt]
                C_4 = \text{if } m = 0 \text{ then } 
                    \beta \textbf{ Drop}
                    \text{ else } \top \\[5pt]
                C_5 = \gamma \neq \text{\textcircled{r}}
                \hspace{2em}
                C_6 = \delta\; \gamma \textbf{ UnboxedNotRecursive}
            \end{array}
        }
    \]
    
    \caption{The updated constraint generation rule for \textsc{Take}}
    \label{fig:takeconstraintgen}
\end{figure}

% PUT constraint gen rule
\begin{figure}
    \centering
    \[
        \infer[\textsc{\footnotesize{CG-Put}}]{
            G_1 \vdash \textsf{put } e_1.f_k = e_2 : \tau_k \rightsquigarrow G_3\; 
                |\; \bigwedge_{k \in 1..5} C_k
        }{
            \begin{array}{c}
                \alpha, \beta, \gamma, \delta \text{ fresh}
                \hspace{2em}
                G_1 \vdash e_1 : \delta\; \{ f^\bullet: \tau | \alpha \}\; 
                    \gamma \rightsquigarrow G_2\; |\; C_1 \\[5pt]
                G_2 \vdash e_2 : \beta \rightsquigarrow G_3\; |\; C_2
                \hspace{2em}
                C_3 =  \delta\; \{ f^\circ : \tau | \alpha \}\; 
                    \gamma \subtype \tau
                \hspace{2em}
                C_4 = \gamma \neq \text{\textcircled{r}} \\[5pt]
                C_5 = \delta\; \gamma \textbf{ UnboxedNotRecursive}
            \end{array}
        }
    \]
    
    \caption{The updated constraint generation rule for \textsc{Put}}
    \label{fig:putconstraintgen}
\end{figure}

Our typing rules and Constraint generation rules have only been changed only to check one extra
constraint on records - that recursive parameters are only used on boxed records. The check for this
new constraint is outlined in \autoref{fig:unboxednotrecursive}

We modify the original \textsc{Take}, \textsc{Put} and \textsc{Member} typing rules defined by
\citet{LiamThesis} to include this constraint as in \autoref{fig:puttypingrule},
\autoref{fig:taketypingrule} and \autoref{fig:membertypingrule}.

Next, we modify the \textsc{CG-Member}, \textsc{CG-Take} and \textsc{CG-Put} for constraint generation,
where our new constraint will be produced, as in \autoref{fig:takeconstraintgen}, 
\autoref{fig:putconstraintgen} and \autoref{fig:memberconstraintgen}, to also include this
new constraint.

Each of these rules additionally now includes an extra fresh unification variable, which is
used to infer the recursive parameter of a given record. These variables are substituted
for real recursive parameters during the constraint solver's \textit{unify} phase.

\section{Constraint Solver Rules}

\begin{figure}
    \centering
    \begin{align}
       t_r  &\subtype \tau  & \simp  && \textbf{unroll } t_r  &\subtype  \tau \label{eq:firsteq} \\
       \tau &\subtype t_r   & \simp  && \tau                  &\subtype  \textbf{unroll } t_r \\
       t_r  &\typeeq  \tau  & \simp  && \textbf{unroll } t_r  &\typeeq   \tau \\
       \tau &\typeeq  t_r   & \simp  && \tau                  &\typeeq   \textbf{unroll } t_r \label{eq:lasteq} \\
       t_r  &\typeeq  k_r   & \simp  && \textbf{unroll } t_r  &=         \textbf{unroll } k_r \label{eq:firstrecs} \\
       t_r  &\subtype k_r   & \simp  && \textbf{unroll } t_r  &=         \textbf{unroll } k_r \label{eq:lastrecs} \\
       (\textbf{mu } t)\; &s\; \textbf{UnboxedNotRecursive}   
            & \simp &&  s = \text{\textcircled{r}} &\lor s = \text{\textcircled{w}} \label{eq:firstunbox} \\
       \varepsilon\; &\text{\textcircled{u}}\; \textbf{UnboxedNotRecursive} 
            & \simp &&  &\varepsilon \label{eq:lastunbox}
    \end{align}
    \caption{The new simplification rules}
    \label{fig:simprules}
\end{figure}

\begin{figure}
    \centering
    \[
        \textbf{unroll } t_r = \textbf{mu } t\; \{ \overline{f_i^u : \tau_i} \} 
    \]
    \caption{the \textbf{unroll} operator, which expands a recursive parameter
             to its recursive reference}
    \label{fig:unrolldef}
\end{figure}

The constraint solver now contains additional rules in order to reason about recursive
records, which have changed the \textit{simplify} and \textit{unify}
constraint solving phases.

\subsection{Simplify Phase}

In the simplify phase, the rules described in \autoref{fig:simprules} allow for
the solver to reason about recursive types type the comparison constraints
subtyping ($\subtype$) and type equality ($\typeeq$). \autoref{eq:firsteq}
through to \autoref{eq:lasteq} state that
when a recursive type $t_r$ is directly compared against a type $\tau$, the solver
can \textbf{unroll} $t_r$, as defined in \autoref{fig:unrolldef}.
Additionally, \autoref{eq:firstrecs} and \autoref{eq:lastrecs} 
cover the case where we compare two recursive parameters
$t_r$ and $k_r$, where we check that \textbf{unroll}ing both parameters results
in the same type via meta equality.

\autoref{eq:firstunbox} and \autoref{eq:lastrecs} allow for the elmination of \textbf{UnboxedNotRecursive} constraints
given that either the recursive parameter is nothing ($\varepsilon$) and the sigil is
unboxed (\textcircled{u}), or that the recursive paremeter is some \textbf{mu} $t$ and
the accompanying sigil $s$ is readonly (\textcircled{r}) or writable (\textcircled{w}).

\subsection{Unify Phase}

The unify phase now unifies unknown recursive parameters that are embedded
on records. Given constraints of the form 
$\alpha\; \{ \dots \} \subtype \mu\; \{ \dots \}$ or of the form
$\alpha\; \{ \dots \} \typeeq \mu\; \{ \dots \}$, where $\alpha$ is a unification
variable and $\mu$ is a concrete recursive parameter, we can simply replace all
$\alpha$ with $\mu$ without an occurs check, and add the substitution 
$\alpha := \mu$ to our set of assignments that the solver will output. 
This is true symmetrically, when the left and right hand sides of the above
constraints are swapped.

The unify phase also now unifies recursive parameters in an \textbf{UnboxedNotRecursive}
constraint to nothing ($\varepsilon$) if the sigil in that constraint has been unified to
an unboxed sigil (\textcircled{u}). If this unification variable was meant to be a recursive
parameter ($t_r$), then the constraint solving will fail elsewhere due to this substitution,
preserving the correctness of the solver.

\section{Termination}

A primitive recursion detection scheme has been designed to check the termination
of functions that structurally recurse on our new recursive types. This introduces
a new phase into the compiler; the \textit{termination checker}.

\subsection{Design}

Our new termination checker works by generating assertions about the structural
size of variables passed to the function, and when any recursive calls are made 
uses these assertions to check that the structural size of the argument to the
recursive call is strictly smaller than that of the function argument, i.e. the argument
given to a recursive call will only ever grow smaller, and hence the function will
eventually reach the `bottom' of the structure and terminate.
As all recursive types constructed must be finite due to our use of strictly positive
types and Cogent's linear type system (no infinitely looping structures),
all primitive recursive calls will terminate.

Our size assertions take the form of two relations between variables, 
size inequality ($\tlt$) and size equality ($\teq$).
$x \tlt y$ is the assertion that a variable $x$ is strictly
structurally smaller than a varialbe $y$ and, $x \teq y$ is the assertion that a
varialbe $x$ is structurally equal in size to a variable $y$.

The checker starts with a set of known termination assertions $G$, and then adds
extra assertions by analysing the expression body of a function to produce
a stronger set of assertions $G'$, as well as a set of expressions that are arguments
to recursive function calls $C$. \autoref{fig:terminationcondition} describes the
condition for soundness of our termination checker. Completeness for the termination
checker is impossible as a consequence of the halting problem, and thus the checker
does not attempt to check more than primitive recursion.

\begin{figure}
    \centering
    \[
        \begin{array}{ll}
            f\; x = e              
                & \text{Given a function definition} \\[10pt]
            \implies \alpha \leftarrow x;\; \varnothing 
                \vdash e \rightsquigarrow G'\; |\; E'\; |\; C
                \hspace{2em}
                & \text{And a set of assertions and goals} \\
                & \text{generated by the termination checker} \\
                & \text{from an initial environment and} \\
                & \text{empty set of assertions} \\[10pt]
            \implies G' \vdash \forall \beta \in C.\; \beta \tlt \alpha
                & \text{The function terminates if} \\
                & \text{every expression produced} \\
                & \text{is smaller than the function argument} \\
                & \text{under the produced assertions}
        \end{array}
    \]
    
    \caption{The termination checker soundness condition}
    \label{fig:terminationcondition}
\end{figure}

We generate such assertions by looking at Cogent's expression langauge 
where any form of structural size is added or taken away, namely
\textsf{take}, \textsf{put} and \textsf{case} expressions.
\autoref{fig:terminationassertiongen} describes this assertion generation.

However, if a user were to shadow a variable in a let expression they may
create a false assertion. Consider the expression 
$\textsf{let } x = C\; x \textsf{ in } \dots$, which would produce the
assertion $x \teq C\; x$, which by our structural size rules can be rewritten as
$x \tlt x$, which is clearly false.

We prevent this from occuring by using a fresh variable name for every
introduced varaible in scope, and use these fresh names in our assertions.
We also store a mapping of program variables to fresh variables names in a
context $E$, which we update as we encounter new variable definitions in the
function expression.

With our current method of size relations, we are unable to reason about variables
comapared against any general expression. For example, suppose the assertion $x \tlt C\; y$.
This assertion is useless to us as we have no way of reasoning about $x$ and $y$ directly,
and we are unable to remove the constructor $C$ as we have no information about the
gap in size between $x$ and $y$. We could have $x \tlt y$ if x is more than 1 layer
of structure smaller than y, or $x \teq y$ if x is only 1 layer of structure smaller.

We seek a way to eliminate such assertions from being generated. To do this,
we define a function \textsf{get} in \autoref{fig:getdef} that maps an expression to
a fresh variable name if the expression is a program variable and otherwise nothing 
($\varepsilon$).
Whenever we generate an assertion against an expression $e$, we use the result
of $\textsf{get}(E,e)$ in the assertion, which will also insert the correct fresh
variable name in the assertion.


\begin{figure}
    \centering
    \[
        \textsf{get}(E, e) = \textsf{if } e = t \textsf{ then } E[t] \textsf{ else } \varepsilon
    \]
    
    \caption{The definition of \textsf{get}}
    \label{fig:getdef}
\end{figure}

After generating all of our assertions, we filter out any assertions that include a nothing ($\varepsilon$),
as we cannot reason about them in any way, or fail if any goal contains a nothing. While this solution may
not be as complete as it possibly could, it allows us to use our assertions to prove termination.

\FloatBarrier

\begin{figure}
    \centering
    \[
        \fbox{$E; G \vdash e : \tau \rightsquigarrow G'\; |\; E'\; |\; C$}
    \]
    \[
        \infer[\textsc{\footnotesize T-Take}]{
            E_1; G_1
                \vdash \textsf{take } r'\; \{ f = x \} = e_1 \textsf{ in } e_2
                \rightsquigarrow G_3\; |\; E_3\; |\; C_1 \cup C_2
        }{
            \begin{array}{c}
            \alpha, \beta\; \textsf{fresh}
            \hspace{1em}
            E_1; \alpha \tlt \textsf{get}(E_1,e_1),\; \textsf{get}(E_1,e_1) \teq \beta,\; G_1 \vdash e_1
                \rightsquigarrow G_2\; |\; E_2\; |\; C_1 \\[5pt]
            E_1, \alpha \leftarrow x, \beta \leftarrow r'; G_2 \vdash e_2 \rightsquigarrow G_3\; |\; E_3\; |\; C_2
            \end{array}
        }
    \]
    \vspace{0.5pt}
    \[
        \infer[\textsc{\footnotesize T-Put}]{
            E_1; G_1 \vdash \textsf{put } e_1.f := e_2
                \rightsquigarrow G_3\; |\; E_1\; |\; C_1 \cup C_2
        }{
            \begin{array}{c}
                \alpha, \beta\; \textsf{fresh}
                \hspace{1em}
                E_1; \alpha \tlt \beta,\; \beta \teq \textsf{get}(E_1,e_1),\; \alpha \teq \textsf{get}(E_1,e_2),\; 
                    G_1 \vdash e_1 \rightsquigarrow G_2\; |\; E_2\; |\; C_1 \\[5pt]
                E_1; G_2 \vdash e_2 \rightsquigarrow G_3\; |\; E_3\; |\; C_2
            \end{array}
        }
    \]
    \vspace{0.5pt}
    \[
        \infer[\textsc{\footnotesize T-Case}]{
            E_1; G_1 \vdash \textsf{case } e_1 \textsf{ of } \kappa\; x.\; e_2\; 
                \textsf{else}\; y.\; e_3
                \rightsquigarrow G_4\; |\; E_1\; |\; C_1 \cup C_2 \cup C_3
        }{
            \begin{array}{c}
                \alpha, \beta, \gamma\; \textsf{fresh}
                \hspace{1em}
                E_1;\; G_1,\; \beta \teq \textsf{get}(E_1, e_1)  \vdash e_1 
                    \rightsquigarrow G_2\; |\; E_2\; |\; C_1 \\[5pt]
                E_1, x \leftarrow \alpha;\; G_2, \alpha \tlt \beta 
                    \vdash e_2 \rightsquigarrow G_3\; |\; E_3\; |\; C_2 \\[5pt]
                E_1, y \leftarrow \gamma;\; G_3, \gamma \teq \beta 
                    \vdash e_3 \rightsquigarrow G_4\; |\; E_4\; |\; C_3
            \end{array}
        }
    \]
    \vspace{0.5pt}
    \[
        \infer[\textsc{\footnotesize T-CaseIrr}]{
            E_1; G_1 \vdash \textsf{case } e_1 \textsf{ of } \kappa\; x.\; e_2\; 
                \rightsquigarrow G_3\; |\; E_1\; |\; C_1 \cup C_2
        }{
            \begin{array}{c}
                \alpha, \beta\; \textsf{fresh}
                \hspace{1em}
                E_1;\; G_1,\; \beta \teq \textsf{get}(E_1, e_1)  \vdash e_1 
                    \rightsquigarrow G_2\; |\; E_2\; |\; C_1 \\[5pt]
                E_1, x \leftarrow \alpha;\; G_2, \alpha \tlt \beta 
                    \vdash e_2 \rightsquigarrow G_3\; |\; E_3\; |\; C_2
                \hspace{2em}
            \end{array}
        }
    \]
    \vspace{0.5pt}
    \[
        \infer[\textsc{\footnotesize T-Member}]{
            E_1; G_1 \vdash e.f
                \rightsquigarrow G_2\; |\; E_1\; |\; C
        }{
            E_1; G_1 \vdash e_1 \rightsquigarrow G_2\; |\; E_2\; |\; C
        }
    \]
    \caption{Termination assertion generation rules}
    \label{fig:terminationassertiongen}
\end{figure}

\begin{figure}[]
    \centering
    \[
        \infer[\textsc{\footnotesize T-Con}]{
            E_1; G_1 \vdash \kappa\; e
                \rightsquigarrow G_2\; |\; E_2\; |\; C
        }{
            E_1; G_1 \vdash e_1 \rightsquigarrow G_2\; |\; E_1\; |\; C
        }
        \hspace{1em}
        \infer[\textsc{\footnotesize T-TApp}]{
            E; G \vdash f\textbf{[}\harpoon{\tau_i}\textbf{]}
                \rightsquigarrow G\; |\; E\; |\; \varnothing
        }{
        }
    \]
    \vspace{0.5pt}
    \[
        \infer[\textsc{\footnotesize T-FApp}]{
            E_1; G_1 \vdash e_1\; e_2
                \rightsquigarrow G_3\; |\; E_1\; |\; C_1 \cup C_2 
                \cup \{\textsf{get}(E_1,e_2)\}
        }{
            E_1; G_1 \vdash e_1 \rightsquigarrow G_2\; |\; E_2\; |\; C_1
            \hspace{1em}
            E_2; G_2 \vdash e_2 \rightsquigarrow G_3\; |\; E_3\; |\; C_2
        }
    \]
    \vspace{0.5pt}
    \[
        \infer[\textsc{\footnotesize T-TVar}]{
            E; G \vdash x
                \rightsquigarrow G\; |\; E\; |\; \varnothing
        }{}
        \hspace{1em}
        \infer[\textsc{\footnotesize T-Lit}]{
            E; G \vdash \ell
                \rightsquigarrow G\; |\; E\; |\; \varnothing
        }{}
    \]
    \vspace{0.5pt}
    \[
        \infer[\textsc{\footnotesize T-PrimOp}]{
            E_1; G_1 \vdash e_1 \text{ \textasteriskcentered }\; e_2
                \rightsquigarrow G_3\; |\; E_1\; |\; C_1 \cup C_2
        }{
            E_1; G_1 \vdash e_1 \rightsquigarrow G_2\; |\; E_2\; |\; C_1
            \hspace{1em}
            E_2; G_2 \vdash e_2 \rightsquigarrow G_3\; |\; E_3\; |\; C_2
        }
    \]
    \vspace{0.5pt}
    \[
        \infer[\textsc{\footnotesize T-Let}]{
            E_1; G_1 \vdash \textsf{let } x = e_1 \textsf{ in } e_2
                \rightsquigarrow G_3\; |\; E_3\; |\; C_1 \cup C_2
        }{
            \begin{array}{c}
                \alpha \; \textsf{fresh}
                \hspace{1em}
                E_1; G_1 \vdash e_1 \rightsquigarrow G_2\; |\; E_2\; |\; C_1 \\[5pt]
                E_1, \alpha \leftarrow x; \alpha \teq \textsf{get}(E_2, e_1),\; G_2 \vdash e_2 
                    \rightsquigarrow G_3\; |\; E_3\; |\; C_2
            \end{array}
        }
    \]
    \vspace{0.5pt}
    \[
        \infer[\textsc{\footnotesize T-If}]{
            E_1; G_1 \vdash \textsf{if } e_1 \textsf{ then } e_2 \textsf{ else } e_3
                \rightsquigarrow G_4\; |\; E_1\; |\; C_1 \cup C_2 \cup C_3
        }{
            \begin{array}{c}
                E_1; G_1 \vdash e_1 \rightsquigarrow G_2\; |\; E_2\; |\; C_1 \\[5pt]
                E_1; G_2 \vdash e_2 \rightsquigarrow G_3\; |\; E_3\; |\; C_2
                \hspace{1em}
                E_1; G_3 \vdash e_3 \rightsquigarrow G_4\; |\; E_4\; |\; C_3
            \end{array}
        }
    \]
    \vspace{0.5pt}
    \[
        \infer[\textsc{\footnotesize T-Tysig}]{
            E_1; G_1 \vdash e :: \tau
                \rightsquigarrow G_2\; |\; E_1\; |\; C
        }{
            E_1; G_1 \vdash e \rightsquigarrow G_2\; |\; E_2\; |\; C
        }
        \hspace{1em}
        \infer[\textsc{\footnotesize T-Struct}]{
            E_1; G_1 \vdash \{\overline{f_i = e_i}\}
                \rightsquigarrow G_{n+1}\; |\; E_1\; |\; \bigcup_{i = 1}^n C_i
        }{
            i \in \{1, \dots, n\}\quad  E_i; G_i \vdash e_i 
                \rightsquigarrow G_{i+1}\; |\; E_{i+1}\; |\; C_i
        }
    \]
    
    \caption{Termination assertion generator rules,
             continiued from \autoref{fig:terminationassertiongen}}
    \label{fig:terminationassertiongen2}
\end{figure}

\begin{figure}
    \centering
    \[
        \begin{array}{lr}
            \text{sumList}\; r =
                & E_1 = \alpha \leftarrow r;\; G_1 = \varnothing\; \\
                & \text{(Initialisation)} \\
                \\
            \hspace{1em}    \textsf{take}\; r'\; \{ l = l \} = r\; \textsf{in} 
                & E_2, = E_1,\; \beta \leftarrow r',\; \gamma \leftarrow l;  \\
                & G_2 = G_1,\; \alpha \teq \beta,\; \gamma \tlt \beta \\
                & \textsc{\footnotesize (T-Take)}\\

            \hspace{2em}    \textsf{case}\; l\; \textsf{of} \\
            \hspace{3em}        \text{Nil}\; u\; \rightarrow\; 0 \\
            \hspace{3em}    |\; v2 \rightarrow 
                & E_3 = E_2,\; u \leftarrow \delta,\; \eta \leftarrow v2; \\
                & G_3 = G_2,\; \delta \tlt \gamma,\; \eta \teq \gamma \\
                & \textsc{\footnotesize (T-Case)}\\
                \\
            \hspace{4em}    \textsf{case}\; v2\; \textsf{of} \\
            \hspace{5em}    \text{Cons}\; s\; \rightarrow 
                & E_4 = E_3,\; \phi \leftarrow s \\
                & G_4 = G_3,\; \phi \tlt \eta \\
                & \textsc{\footnotesize (T-CaseIrr)} \\
                \\
            \hspace{6em}    \textsf{take}\; s'\; \{ rest = r \} = s\; \textsf{in} \hspace{2em}
                & E_5 = E_4,\; \psi \leftarrow s',\; \pi \leftarrow r;  \\
                & G_5 = G_4,\; \psi \teq \phi,\; \pi \tlt \psi  \\
                & \textsc{\footnotesize (T-Take)} \\
                \\
            \hspace{7em}        s.data\; +\; \text{sumList}\; r
                & C = \{\pi\}\\
                & \textsc{\footnotesize (T-FApp)}\\
            \hspace{6em}    \textsf{end} \\
            \hspace{4em}    \textsf{end} \\
            \hspace{2em}    \textsf{end} \\
            \hspace{1em}    \textsf{end};
        \end{array}
    \]
    Final termination assertion generator output:
    \[
        G' = \{\;
            \alpha \teq \beta,\;
            \gamma \tlt \beta,\;
            \delta \tlt \gamma,\;
            \eta \teq \gamma,\;
            \phi \tlt \eta,\;
            \psi \teq \phi,\;
            \pi \tlt \psi,\;
            \pi \tlt \alpha\;
        \} \]
    \[
        C = \{\pi\}    
    \]

    
    \caption{An example of generated termination assertions on a program
             that sums a list of integers}
    \label{fig:exampletermination}
\end{figure}

\FloatBarrier

To determine whether a function terminates, we put our assertions and goals into an
\textit{integer linear programming} (ILP) solver, which finds a valid number 
substitution (i.e. a possible structural size for each variable) to every  
variable in the assertions such that they are all true. If such a substitution exists, 
then the function terminates. Otherwise, we know nothing about the function terminating.

The decision to use an ILP solver comes from their speed. While the ILP
problem is NP-Complete, many ILP solvers are quite fast at finding
solutions, and as Cogent functions produce simple constraints
that only involve equality ($\teq$) and inequality ($\tlt$),
would be especially fast at showing termination.

As an example, consider the program in \autoref{fig:exampletermination} that
features inline termination constraints. Note that our program also shadows
the variable $r$ in the last take, which it generates a different fresh name
for. Using our final set of assertions,
$G'$ and our goal set $C$ we must show that $\pi \tlt \alpha$.
We can perform the following substitutions to show termination:

\begin{center}
    \begin{tabular}{ccccl}
        Assertions & Substitutions &  & Result & \\
        $\alpha \teq \beta$  & $\alpha := 3$ && $3 \teq 3$ & \checkmark \\ 
        $\gamma \tlt \beta$  & $\beta := 3$  && $2 \tlt 3$ & \checkmark \\
        $\delta \tlt \gamma$ & $\delta := 1$ && $1 \tlt 2$ & \checkmark \\
        $\eta \teq \gamma$   & $\gamma := 2$ 
            & $\longrightarrow$\hspace{1em} & $2 \teq 2$   & \checkmark  \\
        $\phi \tlt \eta$     & $\eta := 2$   && $1 \tlt 2$ & \checkmark  \\
        $\psi \teq \phi$     & $\phi := 1$   && $1 \teq 1$ & \checkmark \\
        $\pi \tlt \psi$      & $\psi := 1$   && $0 \tlt 1$ & \checkmark \\
        $\pi \tlt \alpha$    & $\pi  := 0$   && $0 \tlt 4$ & \checkmark 
    \end{tabular}
\end{center}

As our substitution to each variable makes all sizing assertions true,
our given function terminates.

\subsection{Possible Future Improvements}

Earlier, we discussed the problem of only being able to reason about expressions that are
program variables. Our partial solution currently simply eliminates the assertions that
do not reason solely about program variables, however we seek a more complete way to solve
this problem.

One potential idea is to eliminate structural size inequality ($\tlt$), and preserve relative
size information by talking about discrete size changes. Consider our earlier example $x \tlt C\; y$,
where we were unable to remove the constructor $C$ from $y$. 
If earlier when generating this assertion we wrote  $x - 1 \teq C\; y$,
where $x - 1$ means `1 structural size less than $x$', we would be able to know exactly
how much structurally smaller $x$ is than $y$. If we wanted to simplify this assertion,
we could do so by removing the constructor $C$ from $y$, and then taking away one structural size from
the LHS of the assertion, leaving $x - 2 \teq y$.

Not only does this allow us to use this assertion, but we can still use integer linear programming to
solve the series of equations produced, provided all assertions still reference variables directly.
As a result, our termination checker can identify a larger set of functions that are primitive recursive.

Additionally, an alternative to integer linear programming is to construct a directed graph from
our assertions, where variable names are vertices and edges are the relations
between them. For example, $\alpha \tlt \beta$ would produce a directed edge from $\beta$ to
$\alpha$, and $\alpha \teq \beta$ would produce a bidirectional edge between $\alpha$ and $\beta$.
To show termination, we show that there is a one way path from every argument node to every
goal node. This method may be easier to implement than using an ILP solver,
and as it is written exclusively for the Cogent compiler can be optimised
for our use case.

Unfortunately, Cogent integer literals \textsc{U8}, \textsc{U16}, \textsc{U32} and
\textsf{U64} are not structural types, and hence recursion on integers
cannot be detected via our current method. Furthermore, as unsigned integer
overflow is permitted in our Cogent programs, even basic structural integer
recursion could produce a non-terminating program, as a program that takes
away from an integer recursively with no base case can infinitely underflow.

A potential solution to this problem could be to map unsigned integers
and literals to a Peano natural number representation, and require that
each program has an expression with a base case for any recursive call
on integers, and performs recursion by taking only one constructor
away per recursive call, so it does not `skip' a base case.

Finally, while termination checking has been formalised and defined,
it has not yet been implemented in Minigent or Cogent due to it being
only an extension to this thesis. Future work requires the adaptation
of this formalisation to the compiler and to Minigent.


\section{Example Usage and Testing}
\label{ch:examplesandtesting}

\todo{EXAMPLES, move this section before termination?}