\chapter{Completed Work}\label{ch:style}

Considering our investigation, we have expanded upon the existing Cogent infrastructure keeping in mind
three major requirements: the ability for programmers to create recursive, iterable data structures via
recursive types, the necessity for our programs to be easily proven \textit{total},
and the preservation of the benefits guaranteed by Congent's uniqueness types system.

Our proposed design has been implemented in \textit{Minigent}, a stripped down version of Cogent that
features only the type checking component of Cogent in order to focus on integrating smoothly with the 
existing project. This also allows us to focus on the design of our recursive types without having to change
the C code generation and Isabelle embedding of Cogent.

Work has been completed to incorporate our proposed design into the parsing, lexing, reorganising and 
typechecking compiler phases of Minigent, with a rough design of a potential termination checking extension.
In addition to the existing suite of tests in the Minigent typechecker, additional tests have 
been added to test the newly added recursive types.

\todo{Make sure the below addresses the above `three major requirements'}

\section{Grammar and Syntax}

\begin{figure}
    \centering
    \begin{align*}
        \text{types } \tau
            ::= \dots\; &|\; \mu\; \{ \overline{f_i^u\; \tau_i} \} \\
                        &|\; t_r \\
        \text{recursive parameters }\mu ::&= \textbf{mu}\; t\; |\; \varepsilon
    \end{align*}
    \caption{Extending our record syntax with recursive parameters}
    \vspace{2em}
    \label{fig:mu}
\end{figure}

\begin{figure}
    \centering
    \begin{tabular}{l}
        \textbf{type} List = \textbf{mu} $t$ \{ \\
            \phantom{x}\hspace{2em}\textit{l}: $\langle\;$ \\
            \phantom{x}\hspace{4em} $\text{Cons } (t,\textsc{U32})\;$ \\
            \phantom{x}\hspace{3.7em}$|\; \text{Nil } ()\;$ \\
            \phantom{x}\hspace{2em}$\rangle$ \\
        \} 
    \end{tabular}
    \vspace{2em}
    \caption{Constructing the List datatype using recursive parameters}
    \label{fig:muexample}
\end{figure}

We have extended the existing record grammar with an optional recursive parameter \textbf{mu} as in
\autoref{fig:mu} to add recursive type parameters to Cogent's boxed records, and enabled the use
of recursive parameter variables in the language.

Boxed records now feature an optional recursive type variable bound by the \textbf{mu} keyword, which may
feature in a record type in which they are bound. This also our new record syntax to be backwards
compatible with the previous record syntax, enabling existing Cogent programs to remain unchanged.

\autoref{fig:muexample} demostrates the use of our new grammar to construct an integer list datatype,
with the use of a variant type in a recursive record field \textit{l} that is either Nil,
the end of the list, or Cons, the current integer and the rest of the list.

\todo{more examples here? Maybe at the end of this chapter?}

\section{Strictly Positive Types}

\begin{figure}
    \centering
    \begin{gather*}
    \infer[\textsc{sp-rec}]{
        \mathcal{S}; \mathcal{B} \vdash \mu\; \{\overline { f_i : \tau_i } \} \textbf{ SP}
    }{
        \forall \tau_i.\; \mathcal{S}\setminus \textbf{RP}(\mu), \mathcal{B} \cup \textbf{RP}(\mu) \vdash \tau_i \textbf{ SP}
    }
    \hspace{3em}
    \begin{split}
        \textbf{RP}(\textbf{mu } t) &= \{t\} \\
        \textbf{RP}(\varepsilon) &= \{\}
    \end{split} \\[10pt]
    \infer[\textsc{sp-var}]{
        \mathcal{S}; \mathcal{B} \vdash \langle\overline{\kappa_i : \tau_i}\rangle \textbf{ SP}
    }{
        \forall \tau_i.\; \mathcal{S}; \mathcal{B} \vdash \tau_i \textbf{ SP}
    }
    \hspace{3em}
    \infer[\textsc{sp-func}]{
        \mathcal{S}; \mathcal{B} \vdash \tau_1 \rightarrow \tau_2 \textbf{ SP}
    }{
        \mathcal{S} \cup \mathcal{B}; \mathcal{B} \vdash \tau_1 \textbf{ SP}
        &
        \mathcal{S}; \mathcal{B} \vdash \tau_2 \textbf{ SP}
    } \\[10pt]
    \infer[\textsc{sp-rvar}]{
        \mathcal{S}; \mathcal{B} \vdash t_r \textbf{ SP}
    }{
        t_r \notin \mathcal{S}
    }
    \hspace{2em}
    \infer[\textsc{sp-prim}]{
        \mathcal{S}; \mathcal{B} \vdash \mathcal{T} \textbf{ SP}
    }{}
    \hspace{2em}
    \infer[\textsc{sp-tvar}]{
        \mathcal{S}; \mathcal{B} \vdash a \textbf{ SP}
    }{}
    \end{gather*}
    \caption{The rules for checking that Cogent types are strictly positive}
    \label{fig:strictlypositivecheck}
\end{figure}

Checking that all types occur only strictly positive has been implemented in the reorganisation phase of the compiler
instead of during type checking. This allows for a simple one-pass algorithm to analyse all the types in the program
at once, and a simpler contraint generation and solving phases.

\autoref{fig:strictlypositivecheck} describes the strictly positive check over Cogent's types.
This algorithm keeps track of a set of in scope bound recursive parameters $\mathcal{B}$ and a set of recursive
parameters currently in a non-strictly positive position $\mathcal{S}$.

Rule \textsc{sp-rec} describes checking a record bound with a recursive parameter $t$, where parameter 
is added to the bound set $\mathcal{B}$, and removed from the non-strictly positive set $\mathcal{S}$
(as these variables can shadow previous variables), where $\textbf{RP}(\mu)$ returns the recursive
parameter variable in $\mu$ if it has one.

Rule \textsc{sp-func} describes checking a function type, where checking the argument position $\tau_1$ adds
all currently bound ($\mathcal{B}$) parameters to the non-strictly positive set ($\mathcal{S}$), and then
checking the result position $\tau_2$.

Rule \textsc{sp-rvar} describes checking a recursive parameter variable $t_r$, requiring that it is not currently
in a non-strictly positive position (i.e. not in the $\mathcal{S}$ set). 

\textsc{sp-var} merely descends on the types nested within a variant,
\textsc{sp-prim} allows for primitive types ($\mathcal{T}$) and
\textsc{sp-tvar} allows for type variables ($a$).

Once strictly positive typing is checked, the reorganiser will embed all used recursive parameter variables
with a reference to the recursive boxed record that they were bound to, which is used during the constraint
solving phase.

\section{Typing and Constraint Generation Rules}

% Unboxed Not Recursive check
\begin{figure}
    \centering
    $$
        \infer{
            \mu \text{ \textcircled{u} } \textbf{UnboxedNotRecursive}
        }{
            \mu = \varepsilon
        }
    $$
    $$
        \infer{
            (\textbf{mu } t) \text{ s } \textbf{UnboxedNotRecursive}
        }{
            s \neq \text{\textcircled{u}}
        }
    $$
    \caption{A constraint checking that recursive parameters are used only with boxed records}
    \label{fig:unboxednotrecursive}
\end{figure}

% PUT typing rule
\begin{figure}
    \centering
    \begin{align*}
        \infer[\textsc{\footnotesize{Put}}]{
            A;\Gamma \vdash \textsf{put } e_1.f_k  = e_2 : \; \mu \; \{ \overline{f_i^u : \tau_i}, f_k^\circ : \tau_k \} s
        }{
            \begin{array}{c}
                A;\Gamma \vdash e2 : \tau_k
                \hspace{2em}
                A \vdash \Gamma \rightsquigarrow \Gamma_1 \boxplus \Gamma_2
                \hspace{2em}
                s \neq \text{\textcircled{r}}
                \vspace{0.5em} \\
                A;\Gamma_1 \vdash e_1\; : \mu\; \{ \overline{f_i^u : \tau_i}, f_k^\bullet : \tau_k \}\; s
                \vspace{0.5em} \\
                A \vdash \mu \textit{ s } \textbf{UnboxedNotRecursive}
            \end{array}
        }
    \end{align*}
    
    \caption{The updated typing rule for \textsc{put}}
    \label{fig:puttypingrule}
\end{figure}

% TAKE typing rule
\begin{figure}
    \centering
    \begin{align*}
        \infer[\textsc{\footnotesize{Take}}]{
            A;\Gamma \vdash \textsf{take } r \{ f_k = y \} = e1 \textsf{ in } e_2 : \tau
        }{
            \begin{array}{c}
                A \vdash \Gamma \rightsquigarrow \Gamma_1 \boxplus \Gamma_2
                \hspace{3em}
                A;\Gamma_1 \vdash e_1\; : \mu\; \{ \overline{f_i^u : \tau_i}, f_k^\circ : \tau_k \}\; s
                \vspace{0.5em} \\
                A \vdash \mu \textit{ s } \textbf{UnboxedNotRecursive}
                \hspace{3em}
                s \neq \text{\textcircled{r}}
                \vspace{0.5em} \\
                A; r : \mu\; \{ \overline{f_i^u : \tau_i}, f_k^\bullet : \tau_k \}\; s
                ,\; y : \tau_k,\; \Gamma_2 \vdash e_2 : \tau
            \end{array}
        }
    \end{align*}
    
    \caption{The updated typing rule for \textsc{take}}
    \label{fig:taketypingrule}
\end{figure}

% MEMBER typing rule
\begin{figure}
    \centering
    \[
        \infer[\textsc{\footnotesize{Member}}]{
            A;\Gamma \vdash e.f_k : \tau
        }{
            A;\Gamma \vdash e : \mu\; \{ \overline{f_i^\bullet : \tau_i}, f_k^\circ : \tau_k \}\; s
            &\hspace{1em}
            A \vdash \mu \textit{ s } \textbf{UnboxedNotRecursive}
        }
    \]
    
    \caption{The updated typing rule for \textsc{Member}}
    \label{fig:membertypingrule}
\end{figure}

% MEMBER constraint gen rule
\begin{figure}
    \centering
    \[
        \infer[\textsc{\footnotesize{CG-Member}}]{
            G \vdash e.f_k : \tau_k \rightsquigarrow G'\; |\; C_1 \land C_2 \land C_3
        }{
            \begin{array}{c}
                \alpha, \beta, \gamma\; \text{fresh}
                \hspace{2em}
                G \vdash e : \gamma\; \{ f^\circ : \tau | \alpha \}\; \beta \rightsquigarrow G'\; |\; C_1 \\[5pt]
                C_2 = \gamma\; \{ f^\bullet : \tau | \alpha \}\; \beta\; \textbf{Drop}
                \hspace{2em}
                C_3 = \gamma\; \beta\; \textbf{UnboxedNotRecursive}
            \end{array}
        }
    \]
    
    \caption{The updated constraint generation rule for \textsc{Member}}
    \label{fig:memberconstraintgen}
\end{figure}

% TAKE constraint gen rule
\begin{figure}
    \centering
    \[
        \infer[\textsc{\footnotesize{CG-Take}}]{
            G_1 \vdash \textsf{take } x\; \{ f = y \} = e_1 \textsf{ in } e_2
                : \tau \rightsquigarrow G_3 | \bigwedge_{k \in 1..6} C_k
        }{
            \begin{array}{c}
                \alpha, \beta, \gamma, \delta \text{ fresh}
                \hspace{1em}
                G_1 \vdash e : \delta\; \{ f^\circ : \beta\; |\; \alpha \}\;
                    \gamma \rightsquigarrow G_2\; |\; C_1 \\[7pt]
                x :_{\langle 0 \rangle} \delta \{ f^\bullet : \beta | \alpha \} \gamma,\;
                    y :_{\langle 0 \rangle} \beta,\;
                    G_2 \vdash e_2 : \tau 
                     \rightsquigarrow     
                    x :_{\langle n \rangle} \delta \{ f^\bullet : \beta | \alpha \} \gamma,\;
                    y :_{\langle m \rangle} \beta,\;
                    G_3\; |\; C_2 \\[7pt]
                C_3 = \text{if } n = 0 \text{ then } 
                    \delta\; \{ f^\bullet : \beta\; |\; \alpha\; \}\; \gamma \textbf{ Drop}
                    \text{ else } \top \\[5pt]
                C_4 = \text{if } m = 0 \text{ then } 
                    \beta \textbf{ Drop}
                    \text{ else } \top \\[5pt]
                C_5 = \gamma \neq \text{\textcircled{r}}
                \hspace{2em}
                C_6 = \delta\; \gamma \textbf{ UnboxedNotRecursive}
            \end{array}
        }
    \]
    
    \caption{The updated constraint generation rule for \textsc{Take}}
    \label{fig:takeconstraintgen}
\end{figure}

% PUT constraint gen rule
\begin{figure}
    \centering
    \[
        \infer[\textsc{\footnotesize{CG-Put}}]{
            G_1 \vdash \textsf{put } e_1.f_k = e_2 : \tau_k \rightsquigarrow G_3\; 
                |\; \bigwedge_{k \in 1..5} C_k
        }{
            \begin{array}{c}
                \alpha, \beta, \gamma, \delta \text{ fresh}
                \hspace{2em}
                G_1 \vdash e_1 : \delta\; \{ f^\bullet: \tau | \alpha \}\; 
                    \gamma \rightsquigarrow G_2\; |\; C_1 \\[5pt]
                G_2 \vdash e_2 : \beta \rightsquigarrow G_3\; |\; C_2
                \hspace{2em}
                C_3 =  \delta\; \{ f^\circ : \tau | \alpha \}\; 
                    \gamma \subtype \tau
                \hspace{2em}
                C_4 = \gamma \neq \text{\textcircled{r}} \\[5pt]
                C_5 = \delta\; \gamma \textbf{ UnboxedNotRecursive}
            \end{array}
        }
    \]
    
    \caption{The updated constraint generation rule for \textsc{Put}}
    \label{fig:putconstraintgen}
\end{figure}


\todo{Should I talk about my previous attempt and how it failed?}


Our typing rules and Constraint generation rules have only been changed only to check one extra
constraint on records - that recursive parameters are only used on boxed records. The check for this
new constraint is outlined in \autoref{fig:unboxednotrecursive}

We modify the original \textsc{Take}, \textsc{Put} and \textsc{Member} typing rules defined by
\citet{LiamThesis} to include this constraint as in \autoref{fig:puttypingrule},
\autoref{fig:taketypingrule} and \autoref{fig:membertypingrule}.

Next, we modify the textsc{CG-Member}, \textsc{CG-Take} and \textsc{CG-Put} for constraint generation,
where our new constraint will be produced, as in \autoref{fig:takeconstraintgen}, 
\autoref{fig:putconstraintgen} and \autoref{fig:memberconstraintgen}, to also include this
new constraint.

Each of these rules additionally now includes an extra fresh unification variable, which is
used to infer the recursive parameter of a given record. These variables are substituted
for real recursive parameters during the constraint solver's \textit{unify} phase.

\section{Constraint Solver Rules}

\begin{figure}
    \centering
    \begin{align}
       t_r  &\subtype \tau  & \simp  && \textbf{unroll } t_r  &\subtype  \tau \\
       \tau &\subtype t_r   & \simp  && \tau                  &\subtype  \textbf{unroll } t_r \\
       t_r  &\typeeq  \tau  & \simp  && \textbf{unroll } t_r  &\typeeq   \tau \\
       \tau &\typeeq  t_r   & \simp  && \tau                  &\typeeq   \textbf{unroll } t_r \\
       t_r  &\typeeq  k_r   & \simp  && \textbf{unroll } t_r  &=         \textbf{unroll } k_r \\
       t_r  &\subtype k_r   & \simp  && \textbf{unroll } t_r  &=         \textbf{unroll } k_r \\
       (\textbf{mu } t)\; &s\; \textbf{UnboxedNotRecursive}   
            & \simp &&  s = \text{\textcircled{r}} &\lor s = \text{\textcircled{w}} \\
       \varepsilon\; &\text{\textcircled{u}}\; \textbf{UnboxedNotRecursive}   
            & \simp &&  &\varepsilon
    \end{align}
    \caption{The new simplification rules}
    \label{fig:simprules}
\end{figure}

\begin{figure}
    \centering
    \[
        \textbf{unroll } t_r = \textbf{mu } t\; \{\; \dots\; \} 
    \]
    \todo{A real definition (need ideas on how)}
    \caption{the \textbf{unroll} operator}
    \label{fig:unrolldef}
\end{figure}

The constraint solver now contains additional rules in order to reason about recursive
records, which have changed the \textit{simplify} and \textit{unify}
constraint solving phases.

\subsection{Simplify Phase}

In the simplify phase, the rules described in \autoref{fig:simprules} allow for
the solver to reason about recursive types type the comparison constraints
subtyping ($\subtype$) and type equality ($\typeeq$). Rules 3.1 to 3.4 state that
when a recursive type $t_r$ is directly compared against a type $\tau$, the solver
can \textbf{unroll} $t_r$, as defined in \autoref{fig:unrolldef}.
Additionally, rules 3.5 and 3.6 cover the case where we compare two recursive parameters
$t_r$ and $k_r$, where we check that \textbf{unroll}ing both parameters results
in the same type.

Rules 3.7 and 3.8 allow for the elmination of \textbf{UnboxedNotRecursive} constraints
given that either the recursive parameter is nothing ($\varepsilon$) and the sigil is
unboxed (\textcircled{u}), or that the recursive paremeter is some \textbf{mu} $t$ and
the accompanying sigil $s$ is readonly (\textcircled{r}) or writable (\textcircled{w}).

\subsection{Unify Phase}

The unify phase now unifies unknown recursive parameters that are embedded
on records. Given constraints of the form 
$\alpha\; \{ \dots \} \subtype \mu\; \{ \dots \}$ or of the form
$\alpha\; \{ \dots \} \typeeq \mu\; \{ \dots \}$, where $\alpha$ is a unification
variable and $\mu$ is a concrete recursive parameter, we can simply replace all
$\alpha$ with $\mu$ without an occurs check, and add the substitution 
$\alpha := \mu$ to our set of assignments that the solver will output. 
This is true symmetrically, when the left and right hand sides of the above
constraints are swapped.

The unify phase also now unifies recursive parameters in an \textbf{UnboxedNotRecursive}
constraint to nothing ($\varepsilon$) if the sigil in that constraint has been unified to
an unboxed sigil (\textcircled{u}). If this unification variable was meant to be a recursive
parameter ($t_r$), then the constraint solving will fail elsewhere due to this substitution,
preserving the correctness of the solver.

\section{Termination}

A primitive recursion detection scheme has been designed to check the termination
of functions that structurally recurse on our new recursive types. This introduces
a new phase into the compiler; the \textit{termination checker}.

Our new termination checker works by generating assumptions about the structural
size of variables passed to assumptions, and when any recursive calls are made uses these
assumptions to check that the structural size of the argument in the recursive call
is strictly smaller than that of the argument, i.e. the argument given to our function
will only ever grow smaller, and hence the function will eventually reach the `bottom'
of the structure. As all recursive types constructed must be finite due to our use
of strictly positive types and Cogent's linear type system (no infinitely looping
structures), all primitive recursive calls will terminate.

Our size assumptions take the form of 3 relations between variables, $\tlt$, $\teq$, 
and $\tleq$. $x \tlt y$ is the assertion that a variable $x$ is strictly
structurally smaller than a varialbe $y$, $x \teq y$ is the assertion that a
varialbe $x$ is structurally equal in size to a variable $y$, and
$x \tleq y = x \tlt y \lor x \teq y$.

The checker starts with a set of known termination assertions $G$, and then adds
extra assertions by analysing the expression body of a function to produce
a stronger set of assertions $G'$, as well as a set of expressions that are arguments
to recursive function calls $C$: $G \vdash e : \tau \rightsquigarrow G'\; |\; C$.
To show a function $f$ with argument $a$ terminates, we show $\forall e \in C.\; e \tlt a$.

\begin{figure}
    \centering
    \[
        \begin{array}{lr}
            f\; a = e              
                & \text{Given a function definition} \\[10pt]
            \implies G \vdash e \rightsquigarrow G'\; |\; C
                & \text{and a set of assertions and 
                        expressions} \\
                & \text{generated by the termination checker} \\[10pt]
            \implies G' \vdash \forall e' \in C. e' \tlt a
                & \text{The function terminates if} \\
                & \text{every expression produced} \\
                & \text{is smaller than the function argument} \\
                & \text{under the produced assertions}
        \end{array}
    \]

    
    \caption{The termination condition for functions}
    \label{fig:terminationcondition}
\end{figure}

We generate such assertions by looking at Cogent's \textsf{take}, \textsf{put} and \textsf{case}
expressions, which interact with the structure of records and variants.

\begin{figure}
    \centering
    \[
        \fbox{$G \vdash e : \tau \rightsquigarrow G'\; |\; C$}
    \]
    \[
        \infer[\textsc{T-Take}]{
            G_1 \vdash \textsf{take } r'\; \{ f = x \} = e_1 \textsf{ in } e_2
                \rightsquigarrow G_3\; |\; C_1 \cup C_2
        }{
            x \tlt r',\; e_1 \teq r',\; G_1 \vdash e_1 \rightsquigarrow G_2\; |\; C_1
            \hspace{1em}
            G_2 \vdash e_2 \rightsquigarrow G_3\; |\; C_2
        }
    \]
    \[
        \infer[\textsc{T-Put}]{
            G_1 \vdash \textsf{put } e_1.f := e_2
                \rightsquigarrow G_3\; |\; C_1 \cup C_2
        }{
            e_2 \tlt e_1,\; G_1 \vdash e_1 \rightsquigarrow G_2\; |\; C_1
            \hspace{1em}
            G_2 \vdash e_2 \rightsquigarrow G_3\; |\; C_2
        }
    \]
    \[
        \infer[\textsc{T-Case}]{
            G_1 \vdash \textsf{case } e_1 \textsf{ of } \kappa\; e_2
                \rightsquigarrow G_3\; |\; C_1 \cup C_2
        }{
            e_2 \tlt e_1,\; G_1 \vdash e_1 \rightsquigarrow G_2\; |\; C_1
            \hspace{1em}
            G_2 \vdash e_2 \rightsquigarrow G_3\; |\; C_2
        }
    \]
    \[
        \infer[\textsc{T-FApp}]{
            G_1 \vdash e_1\; e_2
                \rightsquigarrow G_3\; |\; C_1 \cup C_2 \cup \{e_2\}
        }{
            G_1 \vdash e_1 \rightsquigarrow G_2\; |\; C_1
            \hspace{1em}
            G_2 \vdash e_2 \rightsquigarrow G_3\; |\; C_2
        }
    \]

    \caption{\todo{Something}}
    \label{fig:terminationassertiongen}
\end{figure}


\pagebreak
\section{Example Usage and Testing}
