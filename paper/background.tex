\chapter{Background And Related Works}\label{ch:background}
Our investigation of existing works will consider three domains: The existing tools within Cogent,
termination and recursive types and linear and uniqueness types.

\section{Cogent Currently}
\todo{Type up}

\section{Termination And Recursive Types}
Our focus for reasoning about termination falls on considering the use of Isabelle to verify our 
embedding as well as facilitating the ease of this process at the type level within Cogent. 

\subsection{Proving Termination in Isabelle}

The official Isabelle tutorial\citep{IsabelleTutorial} describes 3 methods of creating functions using the keywords 
\textbf{primrec}, \textbf{fun} and \textbf{function}. The first, \textbf{primrec}, allows one to create a 
\textit{primitive recursive} function - one that returns a constant or removes a data type constructor from one
of the arguments to the function in its body, `decreasing' in size every time. These functions are \textit{total}
and always terminate, removing the need of a termination proof (which is required for all functions within Isabelle,
unless they are defined to be partial, however this is undesirable).
Primitive recursive functions however are limited in their expressiveness and are a subset of all computable
functions, so we cannot rely on them for the general case.

In his tutorial\citep{KraussIsabelle}, Alexander Krauss discusses the details of the latter two of the 3 methods
of creating functions in Isabelle. The \textbf{fun} keyword instructs Isabelle to try and solve all necessary
termination proof obligations, rejecting the definition if it fails (either because the definition does not 
terminate or because Isabelle cannot figure out how to prove it does). In contrast to this, \textbf{function}
requires that the termination proofs be solved manually by the prover.

\subsection{Strictly Positive Types}

Many theorem provers and dependently typed languages make use of \textit{strictly positive} types, including 
\textit{Agda}\citep{AgdaStrictlyPositive}, \textit{Coq}\citep{CoqStrictlyPositive} and even
Isabelle\citep{IsabelleStrictlyPositive}. Their definitions of strictly positive can be summarised as follows.

\theoremstyle{definition}
\begin{definition}
Given a data type $T$ and its constructors $C_{1..n}$, for every argument $\tau_{ij}$
to any data constructor $C_i$ that is a function, T is said to be \textit{strictly positive} if 
T does not occur as an argument to any $\tau_{ij}$:

\label{def:sp}
\begin{center}
\begin{tabular}{l}
$T = C_1\; \tau_{11} \; \tau_{12} \; \dots$ \\
$\hspace{1.5em} \vert\; C_2\; \tau_{21} \; \tau_{22} \; \dots$ \\
$\hspace{1.5em} \vert\; \dots$ \\
\end{tabular} 

$\forall\; 1 \leq i,j \leq n.\;
 (\tau_{ij} = \phi_{1} \rightarrow \dots \rightarrow \phi_{k})
 \implies T \notin \phi_{1..k-1}$
\end{center}
\end{definition}


\section{Linear \& Uniqueness Types}
\todo{Type up}