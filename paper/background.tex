\chapter{Background \& Related Works}\label{ch:background}
\liam{No ampersands.}\\
Our investigation of existing works will consider 3\liam{three, not 3} domains;\liam{colon, not semi} The existing tools within Cogent,
termination and recursive types, \liam{and} linear and uniqueness types.

\section{Cogent Currently}
\todo{Type up}

\section{Termination \& Recursive Types}
\liam{No ampersands}\\
Our focus for reasoning about termination falls on considering the use of Isabelle to verify our 
embedding as well as facilitating the ease of this process at the type level within Cogent. 
\liam{Little unclear on this paragraph. I'll wait till you write more.}
\subsection{Proving Termination in Isabelle}

The official Isabelle tutorial\cite{IsabelleTutorial} describes 3 methods of creating functions using the keywords 
\textbf{primrec}, \textbf{fun} and \textbf{function}. The first, \textbf{primrec}, allows one to create a 
\textit{primitive recursive} function - one that returns a constant or removes a datatype constructor from one
of the arguments to the function in its body, `decreasing' in size every time. These functions are \textit{total}
and always terminate, removing the need of a termination proof (which is required for all functions within Isabelle,
unless they are defined to be partial, however this is undesirable).
Primitive recursive functions however are limited in their expressiveness and are a subset of all computable
functions, so we cannot rely on them for the general case.

In his tutorial\cite{KraussIsabelle}, Alexander Krauss discusses the details of the latter two of the 3 methods
of creating functions in Isabelle. The \textbf{fun} keyword instructs Isabelle to try and solve all necessary
termination proof obligations, rejecting the definition if it fails (either because the definition does not 
terminate or because Isabelle cannot figure out how to prove it does). In contrast to this, \textbf{funtion}
requires that the termination proofs be solved manually by the prover.
\amos{s/funtion/function/}
\amos{`prover' here is a bit ambigous, as it could refer to the interactive theorem prover (Isabelle) or the person doing the proofs}

\amos{Worth comparing the `gas' or `clock' approach as well, as used by CakeML (see CakeML: A Verified Implementation of ML, POPL 2014).
There, the embedding of the program has an extra parameter which is a natural number describing how much time the program has to compute a result.
At each recursive step, the clock is decremented, and if it reaches zero the program runs out of time and throws an exception.
This lets you embed arbitrary programs as primitive recursion on a nat.
You have to prove termination separately, but you can reason about the program assuming termination (assume that there exists a large enough clock that the program will return a valid value).}

\amos{Something that's unclear to me: do we want to prove termination because we actually want the program to terminate, or do we want to prove termination just because we need to embed it in a theorem prover?}

\todo{Relate to proposal}

\subsection{Strictly Positive Types}

\amos{There's not enough intuition in this section: I'd suggest showing an example of a negative datatype and explaining how it allows unbounded recursion, and then explaining the positivity restriction}

Many theorem provers and dependantly typed languages make use of \textit{strictly positive} types, including 
\textit{Agda}\cite{AgdaStrictlyPositive}, \textit{Coq}\cite{CoqStrictlyPositive} and even
Isabelle\cite{IsabelleStrictlyPositive}. Their definitions of strictly positive can be summarised as follows.

Given a datatype $T$ and its constructors $C_{1..n}$:

\todo{Check definition environment}
$$
T = C_1\; \tau_{11} \; \tau_{12} \; \dots \\
\hspace{1.2em} \vert\; C_2\; \tau_{21} \; \tau_{22} \; \dots \\
\hspace{1.2em} \vert\; \dots
$$
For every argument $\tau_{ij}$ to any type constructor $C_i$ that is a function,
T cannot feature to as an argument to that function:
$$
\forall\; 1 \leq i,j \leq n.\;
 (\tau_{ij} = \phi_{1} \rightarrow \dots \rightarrow \phi_{k})
 \implies T \notin \phi_{1..k-1}
$$


\section{Linear \& Uniqueness Types}
\todo{Type up}
