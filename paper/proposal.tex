\chapter{Proposal and Plan}\label{ch:style}

Considering our investigation, we seek to expand upon the existing Cogent infrastructure keeping in mind
two major requirements: the necessity for our programs to be easily provably \textit{total}, and the preservation 
of the benefits guaranteed by Congent's uniqueness types system.



%%%%%%%%%%
\section{Structure \& Syntax}

\liam{Recommend first justifying the decisions made in the design before presenting the design, but it's up to you.}
We present the syntax for our new recursive types:

\begin{center}
    \textbf{type} Recursive = \textbf{mu} $T$. \{ \textit{field}: $\langle \overline{\kappa^n\; \tau} \rangle$ \}
\end{center}

\liam{A snippet of pseudo-Cogent code is perhaps a bit confusing. Consider taking the grammar of Cogent expressions from 
my thesis and extending it? The overline is not defined anywhere. You should probably have a figure with a grammar. }

Where:
\begin{itemize}
    \item
        \textbf{mu} $T$. is a recursive parameter $T$ that references the following type,
        It may be used in the body of the type
    \item
        \{ \textit{field}: \} is a boxed record with a field in it that has a valid field name
    \item 
        $\langle \overline{\kappa^n\; \tau} \rangle$ is an alternate type with $n$ constructors, 
        with $\kappa^i$ meaning constructor $i$ in the series that takes one argument of type $\tau$
\end{itemize}

Our decision to use Cogent's existing records to house recursive types comes from the fact that they are boxed ---
Cogent's verification framework does not dynamic stack allocation, therefore disallowing our dynamically sized 
recursive data structures on the stack. Hence we turn to the heap, where boxed records are stored.
% \liam{Don't see what this has to do with inputs. Should probably talk about how our C verification framework doesn't support dynamic stack allocation. Explicitly conclude that you can only have dynamically-sized structures by using heap-allocated recursive objects behind a pointer}.
As records are currently implemented in Cogent, adding recursive types would not require new rules
or a new implementation for static memory allocation which is already implemented for records.

Consider the following example recursive type for a list:
\begin{center}
    \textbf{type} List a = \textbf{mu} \textit{T}. \{ deref: $\langle$ Nil () $\vert$ Cons (\textit{a,T}) $\rangle$ \}
\end{center}

The recursive parameter $T$ references the following record, and is used in the \textit{Cons} data constructor
to recursively reference the rest of the list.
The variant type \linebreak {$\langle$ Nil $\vert$ Cons (\textit{a,T}) $\rangle$} we supply as the type of the field
\textit{deref} has two data constructors, \textit{Nil} for the end of the list and \textit{Cons} for an element
followed by the remains of the list. Our list also takes a type parameter $a$, allowing our list to be generic.

We can define a recursive function to sum a U32 List by pattern matching on records as 
in \ref{fig:sum}.

\begin{figure}%[!htbp]
\setstretch{1.2}
    \begin{center}
        \begin{tabular}{l}
            sum : (List U32)! $\rightarrow$ U32 \\
            sum (\textit{r \{ deref \}}) = \\
            \hspace{0.8em} deref \\
                \hspace{2em} $\vert$ Nil  \quad\quad\quad$\,$   $\rightarrow$ 0 \\
                \hspace{2em} $\vert$ Cons (x,r$'$)  $\rightarrow$ x + sum r$'$
        \end{tabular}
    \end{center}
    \caption[short]{a sum function}
    \label{fig:sum}
\end{figure}


%%%%%%%%%%
\section{Totality}

We will require that our recursive types be \textit{strictly positive}, as in \textit{Agda},
\textit{Coq} and Isabelle in order to produce a cleaner and easier to reason about
embedding within Isabelle. As our type system's constraints will be compatable with Isabelle's
strict positivity constraint we can more easily achieve an embedding within Isabelle, and potentially
produce an induction principle within Isabelle to reason about these types directly.

In addition to this, strictly positive types allow us to avoid expressions that are infinitely recursive,
which if iterated over would potentially cause non-termination. Consider
the following example in \textit{Haskell}:

\lstinputlisting[language=haskell]{content/NegativeType.hs}

By our definition in \ref{def:sp}, we can see that our type constructor is \textit{negative}, and
thus allows infinitely recursive expressions. This is not an issue in Haskell due to its lazy evaluation,
however as Cogent is not lazily evaluated these expressions are undesirable in
our language as they will not terminate.
Although this example was constructed maliciously, situations may arise where the
programmer accidentally constructs such an expression, which strictly positive types prohibit.

Given our definition, we can check the strict positivity of a type with the following judgement:
$$
\infer{
    \Gamma \vdash \mu T.\; \{\; f: \langle \overline{\kappa^n\; \tau} \rangle\; \}
}{
   \forall \tau.\; \Gamma \vdash (\tau \sqsubseteq \phi \rightarrow \psi) \implies T \notin \phi
}
$$

Where:
\begin{itemize}
    \item 
        $\tau \sqsubseteq \phi \rightarrow \psi$ is the subtyping relation that $\tau$ 
        is a subtype of $\phi \rightarrow \psi$ 
        (i.e. $\tau$ has the `shape' of a function, from type $\phi$ to $\psi$) 
    \item
        $T \notin \phi$ is the constraint that the recursive parameter $T$ 
        does not exist anywhere in the type $\phi$.
\end{itemize}

In addition to this, any \textit{primitive recursive} functions over our recursive types 
(such as the sum function in figure \ref{fig:sum}) potentially gain the benefit of a guaranteed
automatic termination proof due to an easy to reason about functional embedding within Isabelle.
All other generally recursive functions must be proved manually, however due to our embedding
the cost of such proofs are drastically reduced.

\section{Preservation of Uniqueness}

\todo{Write this}