\chapter{Proposal and Plan}\label{ch:style}

Considering our investigation, we seek to expand upon the existing Cogent infrastructure keeping in mind
two major requirements: the necessity for our programs to be easily provably \textit{total}, and the preservation 
of the benefits guaranteed by Congent's uniqueness types system.



%%%%%%%%%%
\section{Structure \& Syntax}

\liam{Recommend first justifying the decisions made in the design before presenting the design, but it's up to you.}
We present the syntax for our new recursive types:

\begin{center}
    \textbf{type} Recursive = \textbf{mu} $T$. \{ \textit{field}: $\langle \overline{\kappa^n\; \tau} \rangle$ \}
\end{center}

\liam{A snippet of pseudo-Cogent code is perhaps a bit confusing. Consider taking the grammar of Cogent expressions from 
my thesis and extending it? The overline is not defined anywhere. You should probably have a figure with a grammar. }

Where:
\begin{itemize}
   \item
        \textbf{mu} $T$. is a recursive parameter $T$ that references the following type,
        It may be used in the body of the type
    \item
        \{ \textit{field}: \} is a boxed record with a field in it that has a valid field name
    \item 
        $\langle \overline{\kappa^n\; \tau} \rangle$ is an alternate type with $n$ constructors, 
        with $\kappa^i$ meaning constructor $i$ in the series that takes one argument of type $\tau$
\end{itemize}

Our decision to use Cogent's existing records to house recursive types comes from the fact that they are boxed ---
Cogent's verification framework does not allow for dynamic stack allocation, thereby prohibiting
our dynamically sized recursive data structures on the stack. Hence we turn to the heap,
where boxed records are stored. As records are currently implemented in Cogent, adding recursive
types would not require new rules or a new implementation for static memory allocation which
is already implemented for records.

Consider the following example recursive type for a list:
\begin{center}
    \textbf{type} List a = \textbf{mu} \textit{T}. \{ deref: $\langle$ Nil () $\vert$ Cons (\textit{a,T}) $\rangle$ \}
\end{center}

The recursive parameter $T$ references the following record, and is used in the \textit{Cons} data constructor
to recursively reference the rest of the list.
The variant type \linebreak {$\langle$ Nil $\vert$ Cons (\textit{a,T}) $\rangle$} we supply as the type of the field
\textit{deref} has two data constructors, \textit{Nil} for the end of the list and \textit{Cons} for an element
followed by the remains of the list. Our list also takes a type parameter $a$, allowing our list to be generic.

We can define a recursive function to sum a U32 List by pattern matching on records as 
in \ref{fig:sum}.

\begin{figure}%[!htbp]
\setstretch{1.2}
    \begin{center}
        \begin{tabular}{l}
            sum : (List U32)! $\rightarrow$ U32 \\
            sum (\textit{r \{ deref \}}) = \\
            \hspace{0.8em} deref \\
                \hspace{2em} $\vert$ Nil  \quad\quad\quad$\,$   $\rightarrow$ 0 \\
                \hspace{2em} $\vert$ Cons (x,r$'$)  $\rightarrow$ x + sum r$'$
        \end{tabular}
    \end{center}
    \caption[short]{a sum function}
    \label{fig:sum}
\end{figure}


%%%%%%%%%%
\section{Totality}

We will require that our recursive types be \textit{strictly positive}, as in \textit{Agda},
\textit{Coq} and Isabelle in order to produce a cleaner and easier to reason about
embedding within Isabelle. As our type system's constraints will be compatable with Isabelle's
strict positivity constraint we can more easily achieve an embedding within Isabelle, and potentially
produce an induction principle within Isabelle to reason about these types directly.


Given our definition, we can check the strict positivity of a type with the following judgement:
$$
\infer{
    \Gamma \vdash \mu T.\; \{\; f: \langle \overline{\kappa^n\; \tau} \rangle\; \}
}{
   \forall \tau.\; \Gamma \vdash (\tau \sqsubseteq \phi \rightarrow \psi) \implies T \notin \phi
}
$$

Where:
\begin{itemize}
    \item 
        $\tau \sqsubseteq \phi \rightarrow \psi$ is the subtyping relation that $\tau$ 
        is a subtype of $\phi \rightarrow \psi$ 
        (i.e. $\tau$ has the `shape' of a function, from type $\phi$ to $\psi$) 
    \item
        $T \notin \phi$ is the constraint that the recursive parameter $T$ 
        does not exist anywhere in the type $\phi$.
\end{itemize}

In addition to our strict positivity constraint, any \textit{primitive recursive} functions over
our recursive types (such as the sum function in figure \ref{fig:sum}) potentially gain the
benefit of a guaranteed automatic termination proof due to an easy to reason about functional
embedding within Isabelle. All other generally recursive functions must be proved manually,
however due to our embedding the cost of such proofs are drastically reduced.

\amos{The scope isn't clear to me: are you going to restrict functions to be primitive recursive, or allow general recursion?
Will you implement these primrec restrictions?
You're planning on modifying the type system and type checker in minigent, if I remember correctly?
Either way, make it very explicit what parts you will and will not do.
I think you made the scope clear in your talk, so I'd suggest to include anything else you mentioned in your talk.}

\section{Preservation of Uniqueness}

\todo{Write this}
