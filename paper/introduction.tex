\chapter{Introduction}\label{ch:intro}
\liam{Suggest a different font than computer modern for headings.}
% Chapter~\ref{ch:background} Is a chapter reference

Formal verification is the field of computer science that explores the methods that allow us to
  reason rigorously about the functional correctness of programs we write.
One of the benefits of doing so is a proof of correctness for programs with respect to a specification,
  and for well specified programs aids in eliminating bugs and unexpected program behaviour.
Much effort has specifically been put into the verification of low level systems code
  which is critical to the operation of any computer.
The presence of bugs in such a system can lead to security vulnerabilities,
  system crashes and invalid system behaviour, which for mission critical systems is unacceptable and
  for everyday use causes frustration for end users.

Using C to implement this code is a very popular choice in the systems community,
  and there have been many attempts to verify systems code written in C using tools such as 
  AutoCorres~\citep{AutoCorres}, which takes parsed C code and produces a \textit{shallow embedding}
  inside the theorem prover Isabelle/HOL~\cite{IsabelleTutorial}.
This embedding is a representation of the semantics of the C code within the theorem prover,
  however due to the nature of the C language many difficulties arise when trying to
  reason about its functional properties, due to its lack of memory and type safety 
  and its mutable state.

Cogent~\citep{ICFPCogent}, is a domain specific language that was introduced to replace C as a systems
  implementation language.
It is a functional, high level language with uniqueness types and a certifying compiler
  that produces a shallow embedding in Isabelle/HOL as well as low level efficient C code,
  the semantics of which correspond to the the Isabelle embedding.
Due to the functional, high level nature of the embedding 
  which is designed to be reasoned about equationally as well as its resemblance to higher order logic,
  Cogent allows for a much less taxing process of verifying low level systems code.

Cogent is also suitable for low level systems development in contrast to many existing functional languages which operate
  on layers of abstractions away from the system, as its uniqueness type system allows for both efficient destructive updates
  as well as static memory allocation.
In addition to this, Cogent presents a C FFI allowing existing C programs to interact with Cogent code, without forcing teams to
  abandon a project already written in C and already verified.

Cogent however has no support for recursion\liam{spelling} or iteration \liam{``However'' use here seems incorrect, without commas it 
would be contrasting to another language.}. 
Currently, any iterative data type\liam{What's an interactive data type?} and its iterators have to be defined externally in C,
  and included in the Cogent program via its C FFI\liam{Grammar. ``it'' is referring to the Cogent program, which doesn't have an FFI, not to Cogent itself, which does.}.
As it is desirable\liam{Why?} to prove totality about verified code,
  the cost of reasoning about a particular programs\liam{Apostrophe? or ``termination of a particular program''} termination is exacerbated with this overhead,
  due to iteration being an external construct to the language.
This forces the verification effort to again reason about low level C code \liam{Grammar. Effort is not capable of reason.}, which Cogent strives to avoid.

This thesis aims to introduce recursive types to Cogent's type system, allowing internal iteration over
  internal data structures without the involvement of C code.
Whilst providing these benefits\liam{``these''? You only listed one benefit.}, we must also respect the existing guarantees that Cogent enjoys,
  particularly simple reasoning\liam{Ambiguous grammar. (particularly simple) reasoning or particularly (simple reasoning). I think you mean the latter, in which case, use ``In particular'' instead.} about functional correctness (especially with respect to termination and totality)\liam{Functional correctness usually = partial correctness, not total.},
  its static memory allocation and destructive updates all while keeping in mind
  an efficient and low level C representation.