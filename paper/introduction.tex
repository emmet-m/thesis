\chapter{Introduction}\label{ch:intro}
\liam{Suggest a different font than computer modern for headings.}
% Chapter~\ref{ch:background} Is a chapter reference

Formal verification is the field of computer science that explores the methods that allow us to
  reason rigorously about the functional correctness of programs we write. \liam{This isn't motivation. Explain why
  formal verification is desirable, specifically for systems.}
Much effort has specifically been put into the verification of low level systems code,
  which is critical to the operation of any computer.
Using C to implement this code is a very popular choice in the systems community,
  however due to the nature of the language many difficulties arise when trying to
  reason about the functional properties of C code.\liam{Nothing concrete. Perhaps mention lack of memory and type safety. Mutable state complicates verification. You want to make the case that C is really bad, and that moving more C code into Cogent is good, thus motivating your project.}

Cogent\cite{ICFPCogent}, is a domain specific language that was introduced to address these issues.
%Cogent~\citep{OCo16} \liam{Put a non-breakable-space (i.e. \texttt{\textasciitilde}) before any cite. Also, don't use raw \texttt{cite}. We want \texttt{citep} in this case, use natbib or biblatex.}, 
%is a domain specific language that was introduced to address these issues.
%\liam{Cogent isn't intended to address the issues with C. It is intended to replace C to avoid these issues.}
It is a functional, high level language with uniqueness types and a certifying compiler
  that produces a shallow embedding in Isabelle \liam{In this case, say Isabelle/HOL} (the interactive theorem prover \liam{could do a cite instead of a parenthetical}) as well as low level efficient C code,
  the semantics of which correspond to the the Isabelle embedding. \liam{Maybe you want to define embeddings? Talk about how Isabelle is used for verification in the previous paragraph, then you can define embeddings}
This embedding is easy to reason about within Isabelle due to it's functional,
  high level nature, which in term allows for a much less taxing process of verifying low level systems code. \liam{Why? Mention equational reasoning, that the language of the embedding resembles HOL.}

Cogent is also suitable for low level systems development,\liam{Perhaps mention that this is different from other functional languages.}
  as its uniqueness type system allows for both efficient destructive updates as well as static memory allocation.
In addition to this, Cogent presents a C FFI allowing existing C programs to interact with Cogent code without having to
  abandon a project already written in C and already verified \liam{Grammar problem, The subject of this last clause is ``C programs'' , but C programs themselves would never have to abandon a project. }.

Cogent however has no support for recurison\liam{spelling} or iteration \liam{``However'' use here seems incorrect, without commas it 
would be contrasting to another language.}. 
Currently, any iterative data type\liam{What's an interative data type?} and its iterators have to be defined externally in C,
  and included in the Cogent program via its C FFI\liam{Grammar. ``it'' is referring to the Cogent program, which doesn't have an FFI, not to Cogent itself, which does.}.
As it is desirable\liam{Why?} to prove totality about verified code,
  the cost of reasoning about a particular programs\liam{Apostrophe? or ``termination of a particular program''} termination is exacerbated with this overhead,
  due to iteration being an external construct to the language.
This forces the verification effort to again reason about low level C code \liam{Grammar. Effort is not capable of reason.}, which Cogent strives to avoid.

This thesis aims to introduce recursive types to Cogent's type system, allowing internal iteration over
  internal data structures without the involvement of C code.
Whilst providing these benefits\liam{``these''? You only listed one benefit.}, we must also respect the existing guarantees that Cogent enjoys,
  particularly simple reasoning\liam{Ambiguous grammar. (particularly simple) reasoning or particularly (simple reasoning). I think you mean the latter, in which case, use ``In particular'' instead.} about functional correctness (especially with respect to termination and totality)\liam{Functional correctness usually = partial correctness, not total.},
  its static memory allocation and destructive updates all while keeping in mind
  an efficient and low level C representation.